{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Getting started","text":"<p> <pre><code>pip install grugstream\n</code></pre></p>"},{"location":"#introduction","title":"Introduction","text":"<p>The grugstream library provides an easy way to work with asynchronous/ reactive / streaming programming in Python.</p> <p>Set up data processing pipelines that are faster, use less memory and are easy to understand.</p> <p>This library is inspired by - Rxpy, aioreactive - monix</p> <p>Philosophy - when you hit dot on your keyboard - you should have everything you need.</p> <p>Also - everything is statically typed!</p>"},{"location":"#getting-started_1","title":"Getting Started","text":""},{"location":"#basic-example","title":"Basic Example","text":"<p>Generally - what we always do is 1. Create an observable (A stream that is not running yet) 2. Transform it with operators 3. Run it.     - For example, <code>to_list</code> will run the observable and collect the results into a list.    - <code>run_to_completion</code> will run the observable until it completes    - <code>to_file_appending</code> will run the observable and write the results to a file <pre><code>import anyio\nfrom grugstream import Observable\n\n\n# Mock async function simulating an HTTP call to Google\nasync def mock_http_call_to_google(item: str) -&gt; str:\n    # Simulate the asynchronous delay of an HTTP request\n    await anyio.sleep(1)\n    return f\"Response from Google {item}\"\n\n\nasync def main():\n    # Create an observable, and call google for each item\n    observable = (\n        Observable.from_iterable([\"one\", \"two\", \"three\"])\n        # this is the same as map, but it's for async functions\n        .map_async(lambda item: mock_http_call_to_google(item))\n    )\n\n    # Actually start the stream and collect the results into a list\n    results = await observable.to_list()\n\n    for response in results:\n        print(response)\n\n\nanyio.run(main)\n</code></pre></p>"},{"location":"#map-operators-parallel-example","title":"Map operators - Parallel Example","text":"<p>Running things in parallel is as simple as calling <code>map_async_par</code> instead of <code>map_async</code>:</p> <pre><code>import anyio\nfrom grugstream import Observable\n\n\n# Mock async function simulating an HTTP call to Google\nasync def mock_http_call_to_google(item: str) -&gt; str:\n    # Simulate the asynchronous delay of an HTTP request\n    await anyio.sleep(1)\n    return f\"Response from Google {item}\"\n\n\nasync def main():\n    # Create an observable, and call google for each item\n    observable = (\n         # repeat every 0.1 seconds\n        Observable.from_repeat(\"one\", 0.1)\n        # at any given time, there will be at most 50 concurrent calls to google\n        .map_async_par(lambda item: mock_http_call_to_google(item), max_par=50)\n    )\n\n    # Actually start the stream - results into a list\n    # Let's take only 20 results\n    results = await observable.take(20).to_list()\n\n    for response in results:\n        print(response)\n\n\nanyio.run(main)\n</code></pre>"},{"location":"#chaining-other-api-calls","title":"Chaining other api calls","text":"<p>Suppose you have multiple api calls to run. You  want all the api calls to be run in parallel with each other -  the items doing the 2nd api call don't need to wait for all the items for the 1st api call to complete. And maybe you want to stream to a file while it completes. Thats when streaming really shines. <pre><code>import random\nfrom pathlib import Path\nfrom typing import List, Optional\n\nimport anyio\n\nfrom grugstream import Observable\n\n\n# Mock async function simulating an HTTP call to Google\nasync def mock_http_call_to_google(item: str) -&gt; str:\n    await anyio.sleep(1)\n    return f\"Google Response for {item}\"\n\n\n# Mock async function simulating an API call that returns a list of items\nasync def mock_api_call_that_returns_list(item: str) -&gt; List[str]:\n    await anyio.sleep(0.5)\n    return [f\"Item {i} from {item}\" for i in range(3)]\n\n\n# Mock async function simulating an API call that returns an Optional value\nasync def mock_api_call_that_returns_optional(item: str) -&gt; Optional[str]:\n    await anyio.sleep(0.2)\n    maybe_yes = random.choice([True, False])\n    return item if maybe_yes else None\n\n\nasync def main():\n    observable = (\n        Observable.from_repeat(\"query\", 0.1)\n        .map_async_par(lambda item: mock_http_call_to_google(item))\n        .map_async_par(lambda item: mock_api_call_that_returns_list(item))\n        .flatten_iterable()  # Flatten the list into individual items\n        .map_async_par(lambda item: mock_api_call_that_returns_optional(item))\n        .print()\n        .flatten_optional()  # Remove None values\n    )\n\n    # Write the results to a file\n    await observable.take(100).to_file(Path(\"results.txt\"))\n\n\nanyio.run(main)\n</code></pre></p>"},{"location":"#logging-and-debugging-print-and-tqdm","title":"Logging and debugging, print and tqdm","text":"<p>We provide a <code>print</code> and <code>tqdm</code> operator to help you debug your streams.</p> <pre><code>import anyio\nfrom tqdm import tqdm\n\nfrom grugstream import Observable\n\n\n# Mock async function simulating an HTTP call to Google\nasync def mock_http_call_to_google(item: str) -&gt; str:\n    await anyio.sleep(0.1)\n    return f\"Google Response for {item}\"\n\n\nasync def main():\n    observable = (\n        Observable.from_repeat(\"query\", 0.1)\n        .throttle(1)  # don't spam google too much!\n        .map_async_par(lambda item: mock_http_call_to_google(item))\n        # Show a progress bar that should show ~1 it/s\n        .tqdm(tqdm_bar=tqdm(desc=\"Google observable\"))\n        # Print the elements\n        .print()\n    )\n\n    await observable.take(1000).run_to_completion()\n\n\nanyio.run(main)\n</code></pre>"},{"location":"#for_each-operator-side-effects","title":"for_each operator - side effects","text":"<p>Sometimes you want to do something with the elements of the stream, but you don't want to change the stream itself. For example, you might want to write some intermediate items to a file.</p> <pre><code>import anyio\nfrom pathlib import Path\nfrom grugstream import Observable\n\n\n# Mock async function simulating an HTTP call to Google\nasync def mock_http_call_to_google(item: str) -&gt; str:\n    await anyio.sleep(0.1)\n    return f\"Google Response for {item}\"\n\n\nasync def main():\n    my_list = []\n    observable = (\n        Observable.from_repeat(\"query\", 0.1)\n        .map_async_par(lambda item: mock_http_call_to_google(item))\n        # What's google's response? Let's write it to a file\n        .for_each_to_file(\n            file_path=Path(\"results.txt\"),\n        )\n        # Let's also append it to a list to print\n        .for_each(lambda item: my_list.append(item))\n        .map(lambda item: item.upper())\n        .print()\n    )\n\n    await observable.take(1000).run_to_completion()\n    print(my_list)\n\n\nanyio.run(main)\n</code></pre>"},{"location":"#building-an-observable","title":"Building an Observable","text":"<p>This library provides several utility methods for creating observables:</p>"},{"location":"#from-existing-data","title":"From Existing Data","text":"<ul> <li><code>from_iterable(iterable)</code>: Create an observable from a Python iterable like a list or a tuple.</li> <li><code>from_async_iterable(iterable)</code>: Create an observable from an asynchronous iterable.</li> <li><code>from_one(value)</code>: Create an observable that emits a single value.</li> <li><code>from_one_option(value)</code>: Create an observable that emits a single value or nothing if the value is <code>None</code>.</li> </ul> <p>Example:</p> <pre><code>from grugstream import Observable\nobservable = Observable.from_iterable([1, 2, 3])\n</code></pre>"},{"location":"#transforming-observables","title":"Transforming Observables","text":""},{"location":"#map","title":"<code>map</code>","text":"<p>Applies a function to all elements in the source observable.</p> <pre><code>observable = Observable.from_iterable([1, 2, 3])\nnew_observable = observable.map(lambda x: x * 2)\n</code></pre>"},{"location":"#filter","title":"<code>filter</code>","text":"<p>Filters out elements that do not match a given predicate.</p> <pre><code>observable = Observable.from_iterable([1, 2, 3])\nfiltered_observable = observable.filter(lambda x: x &gt; 1)\n</code></pre>"},{"location":"#flatten_iterable","title":"<code>flatten_iterable</code>","text":"<p>Transforms an observable of iterables into an observable of the individual items.</p> <pre><code>observable = Observable.from_iterable([[1, 2], [3, 4]])\nflattened_observable = observable.flatten_iterable()\n</code></pre>"},{"location":"#back-pressure-buffearing-throttling","title":"Back-pressure, Buffearing, Throttling","text":"<p>The library supports back-pressure to ensure that the producer and consumer are in sync. There are also methods like <code>throttle(seconds)</code> to control the rate of emissions.</p> <pre><code>throttled_observable = observable.throttle(1.0)  # Emits at most one item per second\n</code></pre>"},{"location":"#subscription-and-error-handling","title":"Subscription and Error Handling","text":"<p>You can use the <code>Subscriber</code> class to define custom subscribers. It has three methods:</p> <ul> <li><code>on_next(value)</code>: Called when a new value is emitted.</li> <li><code>on_error(error)</code>: Called when an error occurs.</li> <li><code>on_completed()</code>: Called when the observable completes.</li> </ul> <p>In general, I hope that you wouldn't have to implement your own subscriber. Most things you want to do can be done by chaining operators such as <code>map</code> and <code>filter</code>.</p>"},{"location":"2_observable_methods/","title":"Observable methods","text":"<p>             Bases: <code>ABC</code>, <code>Generic[A_co]</code></p> <p>An asynchronous observable (stream)</p> <p>Represents an asynchronous streaming sequence</p> Source code in <code>grugstream/core.py</code> <pre><code>class Observable(ABC, Generic[A_co]):\n    \"\"\"An asynchronous observable (stream)\n\n    Represents an asynchronous streaming sequence\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        ...\n        # self.file_handlers: dict[Path, AsyncFile[str]] = {}\n\n    def from_one(self, value: A) -&gt; \"Observable[A]\":\n        \"\"\"Create an Observable that emits a single value.\n\n        Parameters\n        ----------\n        value :\n            The value to emit.\n\n        Returns\n        -------\n        Observable\n            An Observable that emits the given value.\n\n        Examples\n        --------\n        &gt;&gt;&gt; obs = Observable.from_one(10)\n        &gt;&gt;&gt; await obs.to_list()\n        [10]\n\n        \"\"\"\n        return self.from_iterable([value])\n\n    @classmethod\n    def from_awaitable(cls, awaitable: Awaitable[A]) -&gt; \"Observable[A]\":\n        \"\"\"Create an Observable from an awaitable.\n\n        Parameters\n        ----------\n        awaitable :\n            The awaitable to convert to an Observable.\n\n        Returns\n        -------\n        Observable\n            An Observable emitting the value from the awaitable.\n\n        Examples\n        --------\n        &gt;&gt;&gt; async def get_value():\n        &gt;&gt;&gt;     return 10\n        &gt;&gt;&gt; obs = Observable.from_awaitable(get_value())\n        &gt;&gt;&gt; await obs.to_list()\n        [10]\n        \"\"\"\n\n        async def subscribe(subscriber: Subscriber[A]) -&gt; None:\n            value = await awaitable\n            await subscriber.on_next(value)\n            await subscriber.on_completed()\n\n        return create_observable(subscribe)\n\n    @classmethod\n    def from_empty(cls) -&gt; \"Observable[A]\":  # type: ignore\n        \"\"\"Create an empty Observable that emits no items.\n\n        Returns\n        -------\n        Observable\n            An Observable that emits no items and immediately completes.\n\n        Examples\n        --------\n        &gt;&gt;&gt; obs = Observable.from_empty()\n        &gt;&gt;&gt; await obs.to_list()\n        []\n        \"\"\"\n        return cls.from_iterable([])\n\n    def from_one_option(self, value: A | None) -&gt; \"Observable[A]\":\n        \"\"\"Create an Observable emitting value if not None.\n\n        Parameters\n        ----------\n        value : Any\n            The value to emit. If None, emits nothing.\n\n        Returns\n        -------\n        Observable\n            Observable emitting value if not None, otherwise empty.\n\n        Examples\n        --------\n        &gt;&gt;&gt; obs = Observable.from_one_option(10)\n        &gt;&gt;&gt; await obs.to_list()\n        [10]\n\n        &gt;&gt;&gt; obs = Observable.from_one_option(None)\n        &gt;&gt;&gt; await obs.to_list()\n        []\n        \"\"\"\n        return self.from_iterable([value]) if value is not None else self.from_iterable([])\n\n    @staticmethod\n    def from_iterable(iterable: Iterable[A]) -&gt; \"Observable[A]\":\n        \"\"\"Create an Observable from an iterable data source.\n\n        Parameters\n        ----------\n        iterable : Iterable\n            The iterable source to convert to an Observable\n\n        Returns\n        -------\n        Observable\n            An Observable emitting the values from the iterable\n\n        Examples\n        --------\n        &gt;&gt;&gt; obs = Observable.from_iterable([1, 2, 3])\n        &gt;&gt;&gt; await obs.to_list()\n        [1, 2, 3]\n        \"\"\"\n\n        class IterableObservable(Observable[B]):\n            async def subscribe(self, subscriber: Subscriber[A]) -&gt; None:\n                ack = Acknowledgement.ok\n                for item in iterable:\n                    if ack != Acknowledgement.ok:  # If not OK, then stop.\n                        break\n                    ack = await subscriber.on_next(item)\n                await subscriber.on_completed()\n\n        return IterableObservable()\n\n    @staticmethod\n    def from_many_observables(*observables: Observable[A_co]) -&gt; \"Observable[A_co]\":\n        \"\"\"\n        Create an Observable from multiple Observables.\n        Note that this will try to emit values from the multiple Observables\n        concurrently.\n\n\n        Returns\n        -------\n        Observable\n            Observable emitting all values from nested Observables.\n\n        Examples\n        --------\n        &gt;&gt;&gt; obs1 = Observable.from_iterable([1, 2])\n        &gt;&gt;&gt; obs2 = Observable.from_iterable([3, 4])\n        &gt;&gt;&gt; await Observable.from_many_observables(obs1, obs2).to_list()\n        [1, 3, 2, 4]\n        \"\"\"\n        return Observable.from_iterable(observables).flatten_observable()\n\n    @staticmethod\n    def from_iterable_thunk(thunk: Callable[[], Iterable[A]]) -&gt; \"Observable[A]\":\n        \"\"\"Create an Observable from a thunk that returns an iterable.\n        This is useful if you want to re-evaluate the iterable each time.\n        For example, generators can only be iterated once, so you can use this to\n        re-evaluate the generator each time.\n\n        Parameters\n        ----------\n        thunk : Callable\n            The iterable source to convert to an Observable\n\n        Returns\n        -------\n        Observable\n            An Observable emitting the values from the iterable\n\n        Examples\n        --------\n\n        def gen():\n            for i in range(3):\n                yield i\n\n        &gt;&gt;&gt; obs = Observable.from_iterable_thunk(lambda: [1, 2, 3])\n        &gt;&gt;&gt; await obs.to_list()\n        [1, 2, 3]\n        &gt;&gt;&gt; await obs.to_list() # can be called multiple times, each time it will re-evaluate the thunk\n        [1, 2, 3]\n        \"\"\"\n\n        class IterableObservable(Observable[B]):\n            async def subscribe(self, subscriber: Subscriber[A]) -&gt; None:\n                iterable_ = thunk()\n                ack = Acknowledgement.ok\n                for item in iterable_:\n                    if ack != Acknowledgement.ok:  # If not OK, then stop.\n                        break\n                    ack = await subscriber.on_next(item)\n                await subscriber.on_completed()\n\n        return IterableObservable()\n\n    @staticmethod\n    def from_async_iterable(iterable: AsyncIterable[A]) -&gt; \"Observable[A]\":\n        \"\"\"Create an Observable from an asynchronous iterable.\n\n        Parameters\n        ----------\n        iterable : AsyncIterable\n            The asynchronous iterable to convert to an Observable.\n\n        Returns\n        -------\n        Observable\n            An Observable emitting values from the async iterable.\n\n        Examples\n        --------\n        &gt;&gt;&gt; async def gen():\n        &gt;&gt;&gt;     yield 1\n        &gt;&gt;&gt;     yield 2\n        &gt;&gt;&gt; obs = Observable.from_async_iterable(gen())\n        &gt;&gt;&gt; await obs.to_list()\n        [1, 2]\n        \"\"\"\n\n        class AsyncIterableObservable(Observable[B]):\n            async def subscribe(self, subscriber: Subscriber[A]) -&gt; None:\n                ack = Acknowledgement.ok\n                async for item in iterable:\n                    if ack != Acknowledgement.ok:\n                        break\n                    ack = await subscriber.on_next(item)\n                await subscriber.on_completed()\n\n        return AsyncIterableObservable()\n\n    @staticmethod\n    def from_async_iterable_thunk(thunk: Callable[[], AsyncIterable[A]]) -&gt; \"Observable[A]\":\n        \"\"\"Create an Observable from a thunk that returns an iterable.\n        This is useful if you want to re-evaluate the iterable each time.\n        For example, generators can only be iterated once, so you can use this to\n        re-evaluate the generator each time.\n\n        Parameters\n        ----------\n        thunk : Callable\n            The asynchronous iterable to convert to an Observable.\n\n        Returns\n        -------\n        Observable\n            An Observable emitting values from the async iterable.\n\n        Examples\n        --------\n        &gt;&gt;&gt; async def gen():\n        &gt;&gt;&gt;     yield 1\n        &gt;&gt;&gt;     yield 2\n        &gt;&gt;&gt; obs = Observable.from_async_iterable_thunk(lambda: gen())\n        &gt;&gt;&gt; await obs.to_list()\n        [1, 2]\n        &gt;&gt;&gt; await obs.to_list() # can be called multiple times, each time it will re-evaluate the thunk\n        [1, 2]\n        \"\"\"\n\n        class AsyncIterableObservable(Observable[A]):  # type: ignore\n            async def subscribe(self, subscriber: Subscriber[A]) -&gt; None:\n                generator = thunk()\n                ack = Acknowledgement.ok\n                async for item in generator:\n                    if ack != Acknowledgement.ok:\n                        break\n                    ack = await subscriber.on_next(item)\n                await subscriber.on_completed()\n\n        return AsyncIterableObservable()\n\n    @classmethod\n    def from_receive_stream(cls, stream: MemoryObjectReceiveStream[A]) -&gt; \"Observable[A]\":\n        async def async_iterator() -&gt; AsyncIterable[A]:\n            async with stream:\n                async for item in stream:\n                    yield item\n\n        return cls.from_async_iterable(async_iterator())\n\n    @staticmethod\n    def from_file(file_path: Path) -&gt; \"Observable[str]\":\n        \"\"\"Create an Observable that emits lines from a text file.\n\n        Parameters\n        ----------\n        file_path : Path\n            Path to the text file.\n\n        Returns\n        -------\n        Observable[str]\n            An Observable emitting each line of the text file.\n\n        Examples\n        --------\n        &gt;&gt;&gt; obs = Observable.from_file('data.txt')\n        &gt;&gt;&gt; await obs.take(3).to_list()\n        ['line1', 'line2', 'line3']\n        \"\"\"\n\n        async def async_iterator() -&gt; AsyncIterable[str]:\n            async with await anyio.open_file(file_path) as f:\n                async for line in f:\n                    line_without_newline = line.rstrip('\\n')\n                    yield line_without_newline\n\n        return Observable.from_async_iterable_thunk(lambda: async_iterator())\n\n    @staticmethod\n    def from_interval(seconds: float) -&gt; 'Observable[int]':\n        \"\"\"Create an Observable emitting incremental numbers periodically.\n\n        Emits an infinite sequence of incremental integers, with time\n        period of `seconds` between each emission.\n\n        Parameters\n        ----------\n        seconds : float\n            The interval in seconds between emissions.\n\n        Returns\n        -------\n        Observable[int]\n            An Observable emitting incremental numbers at fixed interval.\n\n        Examples\n        --------\n        &gt;&gt;&gt; obs = Observable.from_interval(1.0)\n        &gt;&gt;&gt; await obs.take(3).to_list()\n        [0, 1, 2]\n        \"\"\"\n\n        async def emit_values(subscriber: Subscriber[int]) -&gt; None:\n            counter = 0\n            ack = Acknowledgement.ok\n            while ack == Acknowledgement.ok:\n                ack = await subscriber.on_next(counter)\n                counter += 1\n                await anyio.sleep(seconds)\n\n        return create_observable(emit_values)\n\n    @staticmethod\n    def from_repeat(\n        value: A,\n        seconds: float,\n    ) -&gt; \"Observable[A]\":\n        async def emit_values(subscriber: Subscriber[A]) -&gt; None:\n            ack = Acknowledgement.ok\n            while ack == Acknowledgement.ok:\n                ack = await subscriber.on_next(value)\n                await anyio.sleep(seconds)\n\n        async def subscribe_async(subscriber: Subscriber[A]) -&gt; None:\n            await emit_values(subscriber)\n\n        return create_observable(subscribe_async)\n\n    @abstractmethod\n    async def subscribe(self, subscriber: \"Subscriber[A_co]\") -&gt; None:\n        \"\"\"Subscribe async subscriber.\"\"\"\n        pass\n\n    def enumerated(self: Observable[A]) -&gt; \"Observable[tuple[int, A]]\":\n        \"\"\"Enumerate the values emitted by this Observable.\n\n        Returns\n        -------\n        Observable\n            An Observable of (index, value) tuples.\n\n        Examples\n        --------\n        &gt;&gt;&gt; obs = Observable.from_iterable(['a', 'b', 'c'])\n        &gt;&gt;&gt; enumerated = obs.enumerated()\n        &gt;&gt;&gt; await enumerated.to_list()\n        [(0, 'a'), (1, 'b'), (2, 'c')]\n\n        \"\"\"\n        source = self\n\n        async def subscribe(subscriber: Subscriber[tuple[int, A]]) -&gt; None:\n            counter = 0\n\n            async def on_next(value: A) -&gt; Acknowledgement:\n                nonlocal counter\n                idx = counter\n                transformed_value = (idx, value)\n                counter = counter + 1\n                return await subscriber.on_next(transformed_value)\n\n            map_subscriber = create_subscriber(\n                on_next=on_next, on_error=subscriber.on_error, on_completed=subscriber.on_completed\n            )\n\n            await source.subscribe(map_subscriber)\n\n        return create_observable(subscribe)\n\n    def product(self: Observable[A], other: Iterable[B]) -&gt; \"Observable[tuple[A, B]]\":\n        \"\"\"Combine values from this Observable with another iterable.\n\n        Parameters\n        ----------\n        other : Iterable\n            The other iterable to combine with.\n\n        Returns\n        -------\n        Observable\n            An Observable of tuples of values from this Observable and the other.\n\n        Examples\n        --------\n        &gt;&gt;&gt; obs = Observable.from_iterable([1, 2])\n        &gt;&gt;&gt; other = ['a', 'b']\n        &gt;&gt;&gt; product = obs.product(other)\n        &gt;&gt;&gt; await product.to_list()\n        [(1, 'a'), (1, 'b'), (2, 'a'), (2, 'b')]\n        \"\"\"\n        return self.map(lambda x: product([x], other)).flatten_iterable()\n\n    def map(self: Observable[A], func: Callable[[A], B_co]) -&gt; \"Observable[B_co]\":\n        \"\"\"Map values emitted by this Observable.\n\n        Applies a mapping function to each item emitted by the source.\n\n        Parameters\n        ----------\n        func : Callable\n            The mapping function to apply to each item.\n\n        Returns\n        -------\n        Observable\n            An Observable with the mapped values.\n\n        Examples\n        --------\n        &gt;&gt;&gt; obs = Observable.from_iterable([1, 2, 3])\n        &gt;&gt;&gt; mapped = await obs.map(lambda x: x * 2).to_list()\n        &gt;&gt;&gt; mapped\n        [2, 4, 6]\n        \"\"\"\n        source = self\n\n        async def subscribe(subscriber: Subscriber[B_co]) -&gt; None:\n            async def on_next(value: A) -&gt; Acknowledgement:\n                try:\n                    transformed_value = func(value)\n                    return await subscriber.on_next(transformed_value)\n                except Exception as e:\n                    await subscriber.on_error(e)\n                    return Acknowledgement.stop\n\n            map_subscriber = create_subscriber(\n                on_next=on_next, on_error=subscriber.on_error, on_completed=subscriber.on_completed\n            )\n\n            await source.subscribe(map_subscriber)\n\n        return create_observable(subscribe)\n\n    def map_enumerated(self, func: Callable[[int, A_co], B_co]) -&gt; \"Observable[B_co]\":\n        \"\"\"Map enumerated values from the Observable.\n\n        Parameters\n        ----------\n        func : Callable\n            The mapping function to apply, taking the index and value.\n\n        Returns\n        -------\n        Observable\n            An Observable with the mapped enumerated values.\n\n        Examples\n        --------\n        &gt;&gt;&gt; obs = Observable.from_iterable(['a', 'b', 'c'])\n        &gt;&gt;&gt; mapped = obs.map_enumerated(lambda i, x: str(i) + x)\n        &gt;&gt;&gt; await mapped.to_list()\n        ['0a', '1b', '2c']\n        \"\"\"\n        return self.enumerated().map_2(func)\n\n    def map_2(self: \"Observable[tuple[A, B]]\", func: Callable[[A, B], C]) -&gt; \"Observable[C]\":\n        \"\"\"Map an Observable of pairs using a two-arg function.\n\n        Parameters\n        ----------\n        func : Callable\n            The mapping function taking two arguments.\n\n        Returns\n        -------\n        Observable\n            An Observable with the mapped values.\n\n        Examples\n        --------\n        &gt;&gt;&gt; obs = Observable.from_iterable([(1, 'a'), (2, 'b')])\n        &gt;&gt;&gt; mapped = obs.map_2(lambda x, y: (x, y.upper()))\n        &gt;&gt;&gt; await mapped.to_list()\n        [(1, 'A'), (2, 'B')]\n        \"\"\"\n        return self.map(lambda x: func(x[0], x[1]))\n\n    def map_async(self: Observable[A], func: Callable[[A], Awaitable[B_co]]) -&gt; 'Observable[B_co]':\n        \"\"\"Map values asynchronously using func.\n\n        Parameters\n        ----------\n        func : Callable\n            Async function to apply to each value.\n\n        Returns\n        -------\n        Observable\n            An Observable with the asynchronously mapped values.\n\n        Examples\n        --------\n        &gt;&gt;&gt; async def double(x):\n        &gt;&gt;&gt;     await asyncio.sleep(1)\n        &gt;&gt;&gt;     return x * 2\n        &gt;&gt;&gt; obs = Observable.from_iterable([1, 2, 3])\n        &gt;&gt;&gt; mapped = obs.map_async(double)\n        &gt;&gt;&gt; await mapped.to_list()\n        [2, 4, 6]\n        \"\"\"\n        source = self\n\n        async def subscribe_async(subscriber: Subscriber[B_co]) -&gt; None:\n            async def on_next(value: A) -&gt; Acknowledgement:\n                try:\n                    transformed_value = await func(value)\n                except Exception as e:\n                    await subscriber.on_error(e)\n                    return Acknowledgement.stop\n\n                return await subscriber.on_next(transformed_value)\n\n            map_subscriber = create_subscriber(\n                on_next=on_next, on_error=subscriber.on_error, on_completed=subscriber.on_completed\n            )\n\n            await source.subscribe(map_subscriber)\n\n        return create_observable(subscribe_async)\n\n    def map_2_async(self: \"Observable[tuple[A, B]]\", func: Callable[[A, B], Awaitable[C]]) -&gt; \"Observable[C]\":\n        \"\"\"Map pairs asynchronously using func.\n\n        Parameters\n        ----------\n        func : Callable\n            Async function taking two arguments to apply.\n\n        Returns\n        -------\n        Observable\n            An Observable with asynchronously mapped values.\n\n        Examples\n        --------\n        &gt;&gt;&gt; async def concat(x, y):\n        &gt;&gt;&gt;     await asyncio.sleep(1)\n        &gt;&gt;&gt;     return f'{x}.{y}'\n        &gt;&gt;&gt; obs = Observable.from_iterable([('a', 1), ('b', 2)])\n        &gt;&gt;&gt; mapped = obs.map_2_async(concat)\n        &gt;&gt;&gt; await mapped.to_list()\n        ['a.1', 'b.2']\n        \"\"\"\n        return self.map_async(lambda x: func(x[0], x[1]))\n\n    def map_blocking_par(\n        self: Observable[A], func: Callable[[A], B_co], max_par: int | CapacityLimiter = 50, max_buffer_size: int = 50\n    ) -&gt; 'Observable[B_co]':\n        \"\"\"Map values blocking functions in parallel using func.\n        Only use this for IO bound functions - e.g. old code that aren't async functions\n\n        Parameters\n        ----------\n        func : Callable\n            blocking function to apply to each value.\n        max_par : int, optional\n            Max number of concurrent mappings.\n        max_buffer_size : int, optional\n            Max size of buffer for pending values.\n\n        Returns\n        -------\n        Observable\n            An Observable with the mapped values.\n\n        Examples\n        --------\n        &gt;&gt;&gt; def slow_double(x):\n        &gt;&gt;&gt;     time.sleep(1)\n        &gt;&gt;&gt;     return x * 2\n        &gt;&gt;&gt; mapped = Observable.map_blocking_par(slow_double).take(10)\n        &gt;&gt;&gt; await mapped.to_list() # runs ~3x faster due to parallel mapping\n        [0, 2, 4, 6, 8, 10, 12, 14, 16, 18]\n        \"\"\"\n        limiter: CapacityLimiter = max_par if isinstance(max_par, CapacityLimiter) else CapacityLimiter(max_par)\n        from anyio import to_thread\n\n        async def wrapped_func(value: A) -&gt; B_co:\n            return await to_thread.run_sync(func, value, limiter=limiter)\n\n        return self.map_async_par(wrapped_func, max_par=int(limiter.total_tokens), max_buffer_size=max_buffer_size)\n\n    def buffer_with_size(self: Observable[A], max_buffer_size: int | None = 100_000) -&gt; 'Observable[A]':\n        \"\"\"Adds a buffer to the stream\n\n        Parameters\n        ----------\n        max_buffer_size : int, optional\n            Max size of buffer for pending values. If None is passed, an infinite buffer is created.\n        \"\"\"\n\n        async def process_with_function(\n            subscriber: Subscriber[A], tg: TaskGroup, receive_stream: MemoryObjectReceiveStream[A]\n        ) -&gt; None:\n            async def process_item(item: A) -&gt; None:\n                ack = await subscriber.on_next(item)\n                if ack == Acknowledgement.stop:\n                    tg.cancel_scope.cancel()\n\n            async for item in receive_stream:\n                tg.start_soon(process_item, item)\n\n        async def subscribe_async(subscriber: Subscriber[A]) -&gt; None:\n            send_stream, receive_stream = create_memory_object_stream(\n                max_buffer_size=max_buffer_size if max_buffer_size is not None else math.inf\n            )\n            try:\n\n                async def on_next(value: A) -&gt; Acknowledgement:\n                    await send_stream.send(value)\n                    return Acknowledgement.ok\n\n                async def on_completed() -&gt; None:\n                    await send_stream.aclose()\n\n                send_to_stream_subscriber = create_subscriber(\n                    on_next=on_next, on_completed=on_completed, on_error=subscriber.on_error\n                )\n\n                async with create_task_group() as tg:\n                    tg.start_soon(self.subscribe, send_to_stream_subscriber)\n                    tg.start_soon(process_with_function, subscriber, tg, receive_stream)\n                await subscriber.on_completed()\n\n            except Exception as e:\n                await subscriber.on_error(e)\n            finally:\n                await send_stream.aclose()\n\n        return create_observable(subscribe_async)\n\n    def map_async_par(\n        self: Observable[A], func: Callable[[A], Awaitable[B]], max_buffer_size: int | None = 100, max_par: int = 50\n    ) -&gt; 'Observable[B]':\n        \"\"\"Map values asynchronously in parallel using func.\n\n        Parameters\n        ----------\n        func : Callable\n            Async function to apply to each value.\n        max_buffer_size : int, optional\n            Max size of buffer for pending values. If None is passed, an infinite buffer is created.\n        max_par : int, optional\n            Max number of concurrent mappings.\n\n        Returns\n        -------\n        Observable\n            An Observable with the asynchronously mapped values.\n\n        Examples\n        --------\n        &gt;&gt;&gt; async def slow_double(x):\n        &gt;&gt;&gt;     await asyncio.sleep(1)\n        &gt;&gt;&gt;     return x * 2\n        &gt;&gt;&gt; source = Observable.interval(0.1).take(10)\n        &gt;&gt;&gt; mapped = source.map_async_par(slow_double, max_par=3)\n        &gt;&gt;&gt; await mapped.to_list() # runs ~3x faster due to parallel mapping\n        [0, 2, 4, 6, 8, 10, 12, 14, 16, 18]\n        \"\"\"\n        source = self\n\n        async def process_with_function(\n            subscriber: Subscriber[B], tg: TaskGroup, receive_stream: MemoryObjectReceiveStream[B]\n        ) -&gt; None:\n            semaphore = anyio.Semaphore(max_par)\n\n            async def process_item(item: A) -&gt; None:\n                async with semaphore:\n                    try:\n                        result = await func(item)\n                    except Exception as e:\n                        await subscriber.on_error(e)\n                        tg.cancel_scope.cancel()\n                    ack = await subscriber.on_next(result)  # type: ignore\n                if ack == Acknowledgement.stop:\n                    tg.cancel_scope.cancel()\n\n            async for item in receive_stream:\n                tg.start_soon(process_item, item) # type: ignore\n\n        async def subscribe_async(subscriber: Subscriber[B]) -&gt; None:\n            send_stream, receive_stream = create_memory_object_stream(\n                max_buffer_size=max_buffer_size if max_buffer_size is not None else math.inf\n            )\n            try:\n\n                async def on_next(value: A) -&gt; Acknowledgement:\n                    await send_stream.send(value)\n                    return Acknowledgement.ok\n\n                async def on_completed() -&gt; None:\n                    await send_stream.aclose()\n\n                send_to_stream_subscriber = create_subscriber(\n                    on_next=on_next, on_completed=on_completed, on_error=subscriber.on_error\n                )\n\n                async with create_task_group() as tg:\n                    tg.start_soon(source.subscribe, send_to_stream_subscriber)\n                    tg.start_soon(process_with_function, subscriber, tg, receive_stream)\n                await subscriber.on_completed()\n\n            except Exception as e:\n                await subscriber.on_error(e)\n            finally:\n                await send_stream.aclose()\n\n        return create_observable(subscribe_async)\n\n    def for_each_count(\n        self: Observable[A], counter: Counter[Any], key: Callable[[A], CanHash] = lambda x: \"count\"\n    ) -&gt; \"Observable[A]\":\n        \"\"\"Increment counter for each value.\n\n        Parameters\n        ----------\n        counter : Counter\n            The counter to increment.\n        key : Callable, optional\n            Function to get the key to increment, by default lambda x: x['count']\n\n        Returns\n        -------\n        Observable\n            Output Observable with values unchanged.\n\n        Examples\n        --------\n        &gt;&gt;&gt; counter = Counter()\n        &gt;&gt;&gt; obs = Observable.from_iterable([1,2,3])\n        &gt;&gt;&gt; obs.for_each_count(counter).run_to_completion()\n        &gt;&gt;&gt; counter\n        Counter({\"count\": 1})\n        \"\"\"\n\n        def counter_update(ele: A):\n            counter_key = key(ele)\n            counter[counter_key] += 1\n\n        return self.for_each(counter_update)\n\n    def for_each(self: Observable[A], func: Callable[[A], Any]) -&gt; \"Observable[A]\":\n        \"\"\"Apply func to each value but don't modify stream.\n\n        Parameters\n        ----------\n        func : Callable\n            Function to apply to each value.\n\n        Returns\n        -------\n        Observable\n            Output Observable with values unchanged.\n\n        Examples\n        --------\n        &gt;&gt;&gt; obs = Observable.from_iterable([1, 2, 3])\n        &gt;&gt;&gt; obs.for_each(print).to_list()\n        1\n        2\n        3\n        [1, 2, 3]\n        \"\"\"\n\n        def return_original(value: A) -&gt; A:\n            func(value)\n            return value\n\n        return self.map(return_original)\n\n    def for_each_enumerated(self: Observable[A], func: Callable[[int, A], Any]) -&gt; \"Observable[A]\":\n        \"\"\"Apply indexed func to each value, but don't modify stream.\n\n        Parameters\n        ----------\n        func : Callable\n            Function accepting index and value.\n\n        Returns\n        -------\n        Observable\n            Output Observable with values unchanged.\n\n        Examples\n        --------\n        &gt;&gt;&gt; obs = Observable.from_iterable(['a', 'b', 'c'])\n        &gt;&gt;&gt; obs.for_each_enumerated(lambda i, x: print(f'{i}: {x}')).to_list()\n        0: a\n        1: b\n        2: c\n        ['a', 'b', 'c']\n        \"\"\"\n\n        def return_original(idx: int, value: A) -&gt; A:\n            func(idx, value)\n            return value\n\n        return self.enumerated().map_2(return_original)\n\n    def for_each_to_list(self: Observable[A], collect_list: list[A]) -&gt; \"Observable[A]\":\n        \"\"\"Append each value to a list.\n\n        Parameters\n        ----------\n        collect_list : list\n            The list to append values to.\n\n        Returns\n        -------\n        Observable\n            Output Observable with values unchanged.\n\n        Examples\n        --------\n        &gt;&gt;&gt; my_list = []\n        &gt;&gt;&gt; obs = Observable.from_iterable([1, 2, 3])\n        &gt;&gt;&gt; obs.for_each_to_list(my_list).to_list()\n        [1, 2, 3]\n        &gt;&gt;&gt; my_list\n        [1, 2, 3]\n        \"\"\"\n\n        def append_to_list(value: A) -&gt; A:\n            collect_list.append(value)\n            return value\n\n        return self.map(append_to_list)\n\n    def for_each_to_stream(self: Observable[A], stream: MemoryObjectSendStream[A]) -&gt; \"Observable[A]\":\n        \"\"\"Send each value to a stream.\n\n        Parameters\n        ----------\n        stream : MemoryObjectSendStream\n            The stream to send values to.\n\n        Returns\n        -------\n        Observable\n            Output Observable with values unchanged.\n\n        Examples\n        --------\n        &gt;&gt;&gt; send_stream, _ = create_memory_object_stream()\n        &gt;&gt;&gt; obs = Observable.from_iterable([1, 2, 3])\n        &gt;&gt;&gt; obs.for_each_to_stream(send_stream)\n        &gt;&gt;&gt; # `send_stream` will have received the values\n        \"\"\"\n\n        async def send(value: A) -&gt; A:\n            await stream.send(value)\n            return value\n\n        return self.map_async(send)\n\n    def on_error_restart(\n        self: Observable[A_co],\n        max_restarts: int | None = 1000,\n        exceptions: tuple[type[Exception]] = (Exception,),\n        log_restarting_func: Callable[[int, Exception], None] | None = lambda restart_count, exception: print(\n            f\"Encountered {exception}, restarting with try {restart_count}\"\n        ),\n        log_unhandled_func: Callable[[int, Exception], None] | None = lambda restart_count, exception: print(\n            f\"Encountered unhandled {exception}, total restarts so far: {restart_count}\"\n        ),\n    ) -&gt; \"Observable[A_co]\":\n        \"\"\"Restarts the observable if the exceptions are encountered\"\"\"\n        source: Observable[A_co] = self\n        count = 0\n        if max_restarts is not None:\n            assert max_restarts &gt; 0, \"max_restarts must be more than 0\"\n        max_restarts_num = max_restarts if max_restarts is not None else math.inf\n\n        async def subscribe(subscriber: Subscriber[A_co]) -&gt; None:\n            class RestartSubscriber(Subscriber[B]):\n                def __init__(self) -&gt; None:\n                    self.__threshold_reached: bool = False\n\n                async def on_error(self, error: Exception) -&gt; None:\n                    if isinstance(error, exceptions):\n                        nonlocal count\n                        count += 1\n                        if count &lt;= max_restarts_num:\n                            if log_restarting_func:\n                                log_restarting_func(count, error)\n                            # restart\n                            # TODO: Trampoline to avoid infinite recursive blowup?\n                            restarted_subscriber = RestartSubscriber()\n                            await source.subscribe(restarted_subscriber)\n                            return None\n                    if log_unhandled_func:\n                        log_unhandled_func(count, error)\n                    # Raise if max restart reached or not caught\n                    self.__threshold_reached = True\n                    raise error\n\n                async def on_next(self, value: B) -&gt; Acknowledgement:\n                    if self.__threshold_reached:\n                        return Acknowledgement.stop\n                    else:\n                        return await subscriber.on_next(value)  # type: ignore\n\n            subscriber_with_on_error = RestartSubscriber()\n\n            await source.subscribe(subscriber_with_on_error)\n\n        return create_observable(subscribe)\n\n    @deprecated(\"Use for_each_to_file_appending instead, mode has been remove\")\n    def for_each_to_file(\n        self,\n        file_path: Path,\n        mode: OpenTextMode = 'a',\n        serialize: Callable[[A_co], str] = str,\n        write_newline: bool = True,\n    ) -&gt; \"Observable[A_co]\":\n        return self.for_each_to_file_appending(file_path, serialize, write_newline)\n\n    def for_each_to_file_appending(\n        self: Observable[A],\n        file_path: Path,\n        serialize: Callable[[A], str] = str,\n        write_newline: bool = True,\n    ) -&gt; \"Observable[A]\":\n        \"\"\"\n        Pass through and appends to a file continuously\n\n        Parameters\n        ----------\n        file_path : Path\n            Path to write the file to.\n        serialize : Callable, default str\n            Function to serialize values to strings.\n        write_newline : bool, default True\n            Whether to write a newline after each value.\n\n        Returns\n        -------\n        Observable\n            Output Observable with values unchanged.\n\n        Examples\n        --------\n        &gt;&gt;&gt; obs = Observable.from_iterable([1, 2, 3])\n        &gt;&gt;&gt; await obs.for_each_to_file(Path('data.txt')).run_to_completion()\n        # data.txt will contain '1\\n2\\n3\\n'\n        \"\"\"\n\n        # need a lock to prevent multiple awaitable when it isn't ok to write yet\n        can_write = anyio.Semaphore(1)\n        source = self\n\n        async def next_subscriber(subscriber: Subscriber[A]) -&gt; None:\n            class AnonSubscriber(Subscriber[Any]):\n                def __init__(self) -&gt; None:\n                    self.file_handlers: dict[Path, AsyncFile[str]] = {}\n\n                async def on_next(self, value: A) -&gt; Acknowledgement:\n                    if file_path not in self.file_handlers:\n                        file_path.parent.mkdir(exist_ok=True, parents=True)\n                        file = await anyio.open_file(file_path, mode=\"a\")\n                        self.file_handlers[file_path] = file\n                    else:\n                        file = self.file_handlers[file_path]\n                    async with can_write:\n                        write_str = serialize(value) + ('\\n' if write_newline else '')\n                        await file.write(write_str)\n\n                    return await subscriber.on_next(value)\n\n                async def on_error(self, error: Exception) -&gt; None:\n                    file = self.file_handlers.get(file_path)\n                    if file is not None:\n                        await file.aclose()\n                    return await subscriber.on_error(error)\n\n                async def on_completed(self) -&gt; None:\n                    file = self.file_handlers.get(file_path)\n                    if file is not None:\n                        await file.aclose()\n                    return await subscriber.on_completed()\n\n            await source.subscribe(AnonSubscriber())\n\n        return create_observable(next_subscriber)\n\n    def for_each_async(self: Observable[A], func: Callable[[A], Awaitable[None]]) -&gt; \"Observable[A]\":\n        \"\"\"Apply asynchronous func to each value.\n\n        Parameters\n        ----------\n        func : Callable\n            Asynchronous function to apply.\n\n        Returns\n        -------\n        Observable\n            Output Observable with values unchanged.\n\n        Examples\n        --------\n        &gt;&gt;&gt; async def print_delayed(x):\n        &gt;&gt;&gt;     await asyncio.sleep(1)\n        &gt;&gt;&gt;     print(x)\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; obs = Observable.from_iterable([1, 2, 3])\n        &gt;&gt;&gt; obs.for_each_async(print_delayed).to_list()\n        1    # printed after 1 second\n        2    # printed after 1 more second\n        3\n        [1, 2, 3]\n        \"\"\"\n\n        async def return_original(value: A) -&gt; A:\n            await func(value)\n            return value\n\n        return self.map_async(return_original)\n\n    def filter(self: Observable[A], predicate: Callable[[A], bool]) -&gt; \"Observable[A_co]\":\n        \"\"\"Filter values emitted by this Observable.\n\n        Parameters\n        ----------\n        predicate : callable\n            The function to evaluate for each item.\n\n        Returns\n        -------\n        Observable\n            An Observable only emitting values where predicate is True.\n\n        Examples\n        --------\n        &gt;&gt;&gt; obs = Observable.from_iterable([1, 2, 3, 4])\n        &gt;&gt;&gt; filtered = obs.filter(lambda x: x % 2 == 0)\n        &gt;&gt;&gt; await filtered.to_list()\n        [2, 4]\n\n        \"\"\"\n\n        async def new_subsribe_func(subscriber: Subscriber[A]) -&gt; None:\n            async def on_next(value: A) -&gt; Acknowledgement:\n                try:\n                    if predicate(value):\n                        return await subscriber.on_next(value)\n                except Exception as e:\n                    await subscriber.on_error(e)\n                    return Acknowledgement.stop\n                return Acknowledgement.ok\n\n            filter_subscriber = create_subscriber(\n                on_next=on_next,\n                on_error=subscriber.on_error,\n                on_completed=subscriber.on_completed,\n            )\n            await self.subscribe(filter_subscriber)\n\n        return create_observable(new_subsribe_func)\n\n    def distinct(self: 'Observable[CanHash]') -&gt; 'Observable[CanHash]':\n        \"\"\"Filter Observable to only emit distinct values.\n\n        Items are compared directly for uniqueness.\n        Note that this requires items to implement __hash__.\n        This uses a set to track seen hashes, so it will use O(n) memory,\n        but should not be that much since it only stores hashes.\n\n        Returns\n        -------\n        Observable\n            Observable that contains items that implement __hash__.\n\n        Examples\n        --------\n        &gt;&gt;&gt; obs = Observable.from_iterable([1, 2, 2, 3, 3, 1])\n        &gt;&gt;&gt; distinct = obs.distinct()\n        &gt;&gt;&gt; await distinct.to_list()\n        [1, 2, 3]\n        \"\"\"\n        return self.distinct_by(lambda x: x)\n\n    def distinct_by(self: 'Observable[A]', key: Callable[[A], CanHash]) -&gt; 'Observable[A_co]':\n        \"\"\"Filter Observable to only emit values with distinct keys.\n\n        Items with different keys are considered distinct.\n        This uses a set to track seen hashes, so it will use O(n) memory,\n        but should not be that much since it only stores hashes.\n\n        Parameters\n        ----------\n        key : Callable\n            Function to extract comparison key for each item.\n\n        Returns\n        -------\n        Observable\n            Observable of items with distinct keys.\n\n        Examples\n        --------\n        &gt;&gt;&gt; obs = Observable.from_iterable([{'id': 1}, {'id': 2}, {'id': 1}])\n        &gt;&gt;&gt; distinct = obs.distinct_by(lambda x: x['id'])\n        &gt;&gt;&gt; await distinct.to_list()\n        [{'id': 1}, {'id': 2}]\n        \"\"\"\n        seen = set[CanHash]()\n\n        async def subscribe_async(subscriber: Subscriber[A]) -&gt; None:\n            async def on_next(value: A) -&gt; Acknowledgement:\n                try:\n                    hashable_value = key(value)\n                    if hashable_value not in seen:\n                        seen.add(hashable_value)\n                        return await subscriber.on_next(value)\n                    return Acknowledgement.ok\n                except Exception as e:\n                    await subscriber.on_error(e)\n                    return Acknowledgement.stop\n\n            distinct_subscriber = create_subscriber(\n                on_next=on_next, on_error=subscriber.on_error, on_completed=subscriber.on_completed\n            )\n\n            await self.subscribe(distinct_subscriber)\n\n        return create_observable(subscribe_async)\n\n    def flatten_iterable(self: 'Observable[Iterable[A]]') -&gt; 'Observable[A]':\n        \"\"\"Flatten an Observable of iterables into an Observable of values.\n\n        Flattens an Observable of nested iterables into a single\n        Observable emitting all the nested values.\n\n        Returns\n        -------\n        Observable[A]\n            Observable emitting all values from nested iterables.\n\n        Examples\n        --------\n        &gt;&gt;&gt; obs = Observable.from_iterable([[1, 2], [3, 4]])\n        &gt;&gt;&gt; flattened = obs.flatten_iterable()\n        &gt;&gt;&gt; await flattened.to_list()\n        [1, 2, 3, 4]\n        \"\"\"\n\n        async def subscribe_async(subscriber: Subscriber[A]) -&gt; None:\n            async def on_next(iterable: Iterable[A]) -&gt; Acknowledgement:\n                for item in iterable:\n                    ack = await subscriber.on_next(item)\n                    if ack == Acknowledgement.stop:\n                        return Acknowledgement.stop\n                return Acknowledgement.ok\n\n            flatten_subscriber = create_subscriber(\n                on_next=on_next, on_error=subscriber.on_error, on_completed=subscriber.on_completed\n            )\n\n            await self.subscribe(flatten_subscriber)\n\n        return create_observable(subscribe_async)\n\n    def flatten_list(self: 'Observable[Sequence[A]]') -&gt; 'Observable[A]':\n        \"\"\"Flatten an Observable of lists into an Observable of values.\"\"\"\n        return self.flatten_iterable()\n\n    def flatten_async_iterable(self: 'Observable[AsyncIterable[A]]') -&gt; 'Observable[A]':\n        \"\"\"Flatten an Observable of async iterables into an Observable of values.\n\n        Flattens an Observable of nested async iterables into a single\n        Observable emitting all the nested values.\n\n        Returns\n        -------\n        Observable[A]\n            Observable emitting all values from nested async iterables.\n\n        Examples\n        --------\n        &gt;&gt;&gt; async def gen(x):\n        &gt;&gt;&gt;     yield x\n        &gt;&gt;&gt; obs = Observable.from_iterable([gen(1), gen(2)])\n        &gt;&gt;&gt; flattened = obs.flatten_async_iterable()\n        &gt;&gt;&gt; await flattened.to_list()\n        [1, 2]\n        \"\"\"\n\n        return self.map(Observable.from_async_iterable).flatten_observable()\n\n    def flatten_optional(self: 'Observable[A | None]') -&gt; 'Observable[A]':\n        \"\"\"Flatten an Observable of Optional values into an Observable of present values.\n\n        Flattens an Observable of Optional values, removing any None values.\n\n        Returns\n        -------\n        Observable[A]\n            Observable only emitting present values, removing any Nones.\n\n        Examples\n        --------\n        &gt;&gt;&gt; obs = Observable.from_iterable([1, None, 2, None, 3])\n        &gt;&gt;&gt; flattened = obs.flatten_optional()\n        &gt;&gt;&gt; await flattened.to_list()\n        [1, 2, 3]\n        \"\"\"\n\n        async def subscribe_async(subscriber: Subscriber[A]) -&gt; None:\n            async def on_next(value: A | None) -&gt; Acknowledgement:\n                if value is not None:\n                    return await subscriber.on_next(value)\n                return Acknowledgement.ok\n\n            flatten_subscriber = create_subscriber(\n                on_next=on_next, on_error=subscriber.on_error, on_completed=subscriber.on_completed\n            )\n\n            await self.subscribe(flatten_subscriber)\n\n        return create_observable(subscribe_async)\n\n    def flatten_observable_sequential(self: 'Observable[Observable[B]]') -&gt; 'Observable[B]':\n        \"\"\"Flatten Observable of Observables into one Observable.\n\n        Flattens an Observable emitting other Observables, into a single\n        Observable emitting all the values from the nested Observables.\n        Note that this outputs values from the nested Observables in\n        sequential order.\n\n        Returns\n        -------\n        Observable[B]\n            Observable emitting all values from nested Observables.\n\n        Examples\n        --------\n        &gt;&gt;&gt; obs1 = Observable.from_iterable([1, 2])\n        &gt;&gt;&gt; obs2 = Observable.from_iterable([3, 4])\n        &gt;&gt;&gt; outer = Observable.from_iterable([obs1, obs2])\n        &gt;&gt;&gt; flattened = outer.flatten_observable()\n        &gt;&gt;&gt; await flattened.to_list()\n        [1, 2, 3, 4]\n        \"\"\"\n\n        async def subscribe_async(subscriber: Subscriber[B]) -&gt; None:\n            async def on_inner_next(value: B) -&gt; Acknowledgement:\n                return await subscriber.on_next(value)\n\n            async def on_next(inner_observable: Observable[B]) -&gt; Acknowledgement:\n                inner_subscriber = create_subscriber(\n                    on_next=on_inner_next, on_error=subscriber.on_error, on_completed=subscriber.on_completed\n                )\n                await inner_observable.subscribe(inner_subscriber)\n                return Acknowledgement.ok\n\n            flatten_subscriber = create_subscriber(\n                on_next=on_next, on_error=subscriber.on_error, on_completed=subscriber.on_completed\n            )\n\n            await self.subscribe(flatten_subscriber)\n\n        return create_observable(subscribe_async)\n\n    def flatten_observable(self: 'Observable[Observable[B]]') -&gt; 'Observable[B]':\n        \"\"\"Flatten Observable of Observables into one Observable.\n\n        Flattens an Observable emitting other Observables, into a single\n        Observable emitting all the values from the nested Observables.\n        Note that this will try to emit values from the nested Observables\n        concurrently.\n\n\n        Returns\n        -------\n        Observable[B]\n            Observable emitting all values from nested Observables.\n\n        Examples\n        --------\n        &gt;&gt;&gt; obs1 = Observable.from_iterable([1, 2])\n        &gt;&gt;&gt; obs2 = Observable.from_iterable([3, 4])\n        &gt;&gt;&gt; outer = Observable.from_iterable([obs1, obs2])\n        &gt;&gt;&gt; flattened = outer.flatten_observable()\n        &gt;&gt;&gt; await flattened.to_list()\n        [1, 3, 4, 2]\n        \"\"\"\n\n        async def subscribe_async(subscriber: Subscriber[B]) -&gt; None:\n            async def subscribe_inner(inner_observable: Observable[B]) -&gt; None:\n                async def on_next(value: B) -&gt; Acknowledgement:\n                    ack = await subscriber.on_next(value)\n                    if ack == Acknowledgement.stop:\n                        tg.cancel_scope.cancel()\n                    return ack\n\n                async def on_error(e: Exception) -&gt; None:\n                    tg.cancel_scope.cancel()\n                    await subscriber.on_error(e)\n\n                async def on_completed() -&gt; None:\n                    await subscriber.on_completed()\n\n                await inner_observable.subscribe(\n                    create_subscriber(on_next=on_next, on_error=on_error, on_completed=on_completed)\n                )\n\n            async with anyio.create_task_group() as tg:\n                async for inner_observable in self.to_async_iterable():\n                    tg.start_soon(subscribe_inner, inner_observable)\n\n        return create_observable(subscribe_async)\n\n    def merge_with(self: 'Observable[A_co]', *others: 'Observable[A_co]') -&gt; 'Observable[A_co]':\n        \"\"\"Merge this Observable with other Observables.\n\n        Parameters\n        ----------\n        others : Observable\n            Other Observables to merge with.\n        Returns\n        -------\n        Observable\n            Observable emitting values from this and others Observables. Note that this\n            will not preserve order between Observables.\n\n        Examples\n        --------\n        &gt;&gt;&gt; obs1 = Observable.from_iterable([1, 2])\n        &gt;&gt;&gt; obs2 = Observable.from_iterable([3, 4])\n        &gt;&gt;&gt; merged = obs1.merge_with(obs2)\n        &gt;&gt;&gt; await merged.to_list()\n        [1, 3, 4, 2]\n        \"\"\"\n        new = self.from_iterable([self, *others])\n        return new.flatten_observable()\n\n    def throttle(self, seconds: float, max_buffer_size: int = 1) -&gt; 'Observable[A_co]':\n        \"\"\"Throttle emissions to at most one per `seconds` interval.\n\n        Parameters\n        ----------\n        seconds : float\n            Interval duration between emissions\n        max_buffer_size : int, default 1\n            Max number of values to buffer\n\n        Returns\n        -------\n        Observable\n            Throttled Observatory allowing at most one emission per interval\n\n        Examples\n        --------\n        &gt;&gt;&gt; obs = Observable.interval(0.1)\n        &gt;&gt;&gt; throttled = obs.throttle(1.0)\n        &gt;&gt;&gt; await throttled.take(3).to_list()\n        [0, 1, 2] # emitted at 1 second intervals\n        \"\"\"\n        source = self\n        send_stream, receive_stream = create_memory_object_stream(max_buffer_size=max_buffer_size)  # type: ignore\n\n        class ThrottledObservable(Observable[A]):\n            async def subscribe(self, subscriber: Subscriber[A]) -&gt; None:\n                async def wait_and_forward() -&gt; None:\n                    async with create_task_group() as tg:\n                        # Producer task\n                        tg.start_soon(source.subscribe, send_to_stream_subscriber)\n\n                        # Consumer task\n                        tg.start_soon(send_periodically, tg)\n\n                async def send_periodically(tg: TaskGroup) -&gt; None:\n                    while True:\n                        await anyio.sleep(seconds)\n                        try:\n                            value = receive_stream.receive_nowait()\n                            response = await subscriber.on_next(value)  # type: ignore\n                            if response == Acknowledgement.stop:\n                                await subscriber.on_completed()\n                                tg.cancel_scope.cancel()\n                                break\n                        except anyio.WouldBlock:\n                            # No new elements, keep waiting\n                            continue\n                        except EndOfStream:\n                            await subscriber.on_completed()\n                            break\n\n                async def on_next(value: A) -&gt; Acknowledgement:\n                    await send_stream.send(value)\n                    return Acknowledgement.ok\n\n                async def on_completed() -&gt; None:\n                    await send_stream.aclose()\n\n                async def on_error(e: Exception) -&gt; None:\n                    send_stream.close()\n                    await subscriber.on_error(e)\n\n                send_to_stream_subscriber = create_subscriber(\n                    on_next=on_next, on_completed=on_completed, on_error=on_error\n                )\n\n                await wait_and_forward()\n\n        return ThrottledObservable()\n\n    def print(\n        self: \"Observable[A_co]\", prefix: str = \"\", printer: Callable[[A_co], None] = print\n    ) -&gt; \"Observable[A_co]\":\n        \"\"\"Print values from the Observable using print().\n\n        Prints each value emitted by the Observable after prepending\n        `prefix`.\n\n        Parameters\n        ----------\n        prefix : str, default \"\"\n            String to prepend to printed values.\n        printer : Callable, default print\n            Function to use for printing.\n\n        Returns\n        -------\n        Observable\n            Output Observable with unchanged values.\n\n        Examples\n        --------\n        &gt;&gt;&gt; obs = Observable.from_iterable([1, 2, 3])\n        &gt;&gt;&gt; obs.print(\"Item: \").to_list()\n        Item: 1\n        Item: 2\n        Item: 3\n        [1, 2, 3]\n        \"\"\"\n        return self.for_each(lambda x: printer(f\"{prefix}{x}\"))  # type: ignore\n\n    def tqdm(self, tqdm_bar: Optional[tqdm] = None) -&gt; 'Observable[A_co]':  # type: ignore\n        \"\"\"Wrap the Observable with a tqdm progress bar.\n\n        Parameters\n        ----------\n        tqdm_bar : Optional[tqdm], default None\n            tqdm progress bar to use, or None to use default\n\n        Returns\n        -------\n        Observable\n            Wrapped Observatory with tqdm progress bar\n\n        Examples\n        --------\n        &gt;&gt;&gt; from tqdm import tqdm\n        &gt;&gt;&gt; pbar = tqdm(desc=\"Progress\")\n        &gt;&gt;&gt; obs = Observable.from_interval(1)\n        &gt;&gt;&gt; obs.tqdm(pbar).take(10).run_to_completion()\n        # pbar will show 1 it/s progress\n        \"\"\"\n        source = self\n\n        try:\n            from tqdm import tqdm\n        except ImportError:\n            raise ImportError(\"You need to install tqdm to use this function.\")\n\n        class TQDMObservable(Observable[A]):\n            async def subscribe(self, subscriber) -&gt; None:\n                pbar = tqdm(dynamic_ncols=True) if tqdm_bar is None else tqdm_bar  # type: ignore\n\n                async def on_next(value: A) -&gt; Acknowledgement:\n                    pbar.update(1)\n                    return await subscriber.on_next(value)\n\n                async def on_completed() -&gt; None:\n                    pbar.close()\n                    await subscriber.on_completed()\n\n                async def on_error(e: Exception) -&gt; None:\n                    pbar.close()\n                    await subscriber.on_error(e)\n\n                wrapped_subscriber = create_subscriber(on_next=on_next, on_completed=on_completed, on_error=on_error)\n\n                await source.subscribe(wrapped_subscriber)\n\n        return TQDMObservable()\n\n    async def to_list(self: Observable[A]) -&gt; list[A]:\n        \"\"\"Collect all values from the Observable into a list.\n\n        Returns\n        -------\n        list\n            List containing all values emitted by the Observable.\n\n        Examples\n        --------\n        &gt;&gt;&gt; obs = Observable.from_interval(0.1).take(3)\n        &gt;&gt;&gt; await obs.to_list()\n        [1, 2, 3]\n        \"\"\"\n        result = []\n\n        async def on_next(value: A) -&gt; Acknowledgement:\n            result.append(value)\n            return Acknowledgement.ok\n\n        list_subscriber: Subscriber[A] = create_subscriber(\n            on_next=on_next,\n            on_error=None,\n            on_completed=None,\n        )\n        await self.subscribe(list_subscriber)\n\n        return result\n\n    async def to_slist(self) -&gt; 'Slist[A_co]':\n        \"\"\"Collect values into an Slist.\n\n        Returns\n        -------\n        Slist\n            Slist containing all values emitted.\n\n        Examples\n        --------\n        &gt;&gt;&gt; obs = Observable.from_iterable([1, 2, 3])\n        &gt;&gt;&gt; await obs.to_slist()\n        Slist([1, 2, 3])\n        \"\"\"\n        return Slist(await self.to_list())\n\n    async def to_set(self: \"Observable[CanHash]\") -&gt; set[CanHash]:\n        \"\"\"Collect values into a set, removing duplicates.\n\n        Returns\n        -------\n        set\n            Set containing unique values emitted.\n\n        Examples\n        --------\n        &gt;&gt;&gt; obs = Observable.from_iterable([1, 2, 1])\n        &gt;&gt;&gt; await obs.to_set()\n        {1, 2}\n        \"\"\"\n        result = set()\n\n        async def on_next(value: CanHash) -&gt; Acknowledgement:\n            result.add(value)\n            return Acknowledgement.ok\n\n        set_subscriber = create_subscriber(on_next=on_next, on_completed=None, on_error=None)\n\n        await self.subscribe(set_subscriber)\n\n        return result\n\n    async def to_async_iterable(self) -&gt; AsyncIterable[A_co]:\n        \"\"\"Collect values into an async iterable.\n\n        Returns\n        -------\n        AsyncIterable[A_co]\n            Async iterable containing all emitted values.\n\n        Examples\n        --------\n        &gt;&gt;&gt; obs = Observable.from_iterable([1, 2, 3])\n        &gt;&gt;&gt; async for value in obs.to_async_iterable():\n        &gt;&gt;&gt;     print(value)\n        1\n        2\n        3\n        \"\"\"\n        items = []\n        event = anyio.Event()\n        processing_limit = anyio.CapacityLimiter(1)\n\n        class BufferingSubscriber(Subscriber[A]):\n            async def on_next(self, value: A) -&gt; Acknowledgement:\n                await processing_limit.acquire_on_behalf_of(value)\n                items.append(value)\n                return Acknowledgement.ok\n\n            async def on_error(self, error: Exception) -&gt; None:\n                event.set()\n                raise error\n\n            async def on_completed(self) -&gt; None:\n                event.set()\n\n        buffering_subscriber = BufferingSubscriber()\n        async with anyio.create_task_group() as task_group:\n\n            async def run_subscription():\n                try:\n                    await self.subscribe(buffering_subscriber)\n                finally:\n                    event.set()\n\n            task_group.start_soon(run_subscription)\n\n            while not event.is_set() or items:\n                await anyio.sleep(0)\n\n                while items:\n                    item = items.pop(0)\n                    if isinstance(item, Exception):\n                        raise item\n                    else:\n                        yield item\n                    processing_limit.release_on_behalf_of(item)\n\n    @deprecated(\"Use to_file_appending or to_file_overwriting instead, mode has been removed\")\n    async def to_file(\n        self,\n        file_path: Path,\n        mode: OpenTextMode = 'a',\n        serialize: Callable[[A_co], str] = str,\n        write_newline: bool = True,\n    ) -&gt; None:\n        await self.to_file_appending(file_path, serialize, write_newline)\n\n    async def to_file_appending(\n        self: Observable[A],\n        file_path: Path,\n        serialize: Callable[[A], str] = str,\n        write_newline: bool = True,\n    ) -&gt; None:\n        \"\"\"Write all emitted values to a file, by appending.\n        Note that this appends to a file, rather than overwriting it.\n\n        Parameters\n        ----------\n        file_path : Path\n            Path to write output file to.\n        serialize : Callable, default str\n            Function to serialize items to strings.\n        write_newline : bool, default True\n            Whether to write newline after each value.\n        Examples\n        --------\n        &gt;&gt;&gt; obs = Observable.from_iterable([1, 2, 3])\n        &gt;&gt;&gt; await obs.to_file('data.txt')\n        \"\"\"\n\n        # lock to prevent multiple awaitables from writing at the same time\n        can_write = anyio.Semaphore(1)\n\n        class AnonymousSubscriber(Subscriber[Any]):\n            def __init__(self) -&gt; None:\n                self.file_handlers: dict[Path, AsyncFile[str]] = {}\n\n            async def on_next(self, value: A) -&gt; Acknowledgement:\n                # Only open file ONCE when first value is received\n                if file_path not in self.file_handlers:\n                    file_path.touch(exist_ok=True)\n                    file = await anyio.open_file(file_path, mode=\"a\")\n                    self.file_handlers[file_path] = file\n                else:\n                    file = self.file_handlers[file_path]\n                async with can_write:\n                    await file.write(serialize(value) + ('\\n' if write_newline else ''))\n                return Acknowledgement.ok\n\n            async def on_error(self, error: Exception) -&gt; None:\n                file = self.file_handlers.get(file_path)\n                if file is not None:\n                    await file.aclose()\n                raise error\n\n            async def on_completed(self) -&gt; None:\n                file = self.file_handlers.get(file_path)\n                if file is not None:\n                    await file.aclose()\n                return None\n\n        new_subscriber = AnonymousSubscriber()\n\n        await self.subscribe(new_subscriber)\n\n    async def to_file_overwriting(\n        self: Observable[A],\n        file_path: Path,\n        serialize: Callable[[A], str] = str,\n        write_newline: bool = True,\n        write_every_n: int = 100,\n    ) -&gt; None:\n        \"\"\"Write all emitted values to a file, by overwriting the current file.\n        Note that this stores values to a buffer, so this can lead to an OOM in large files.\n        We recommend to use to_file_appending instead if memory is a concern\n\n        Parameters\n        ----------\n        file_path : Path\n            Path to write output file to.\n        serialize : Callable, default str\n            Function to serialize items to strings.\n        write_newline : bool, default True\n            Whether to write newline after each value.\n        write_every_n : int, default 200\n            Only writes to the file every n values. A higher value prevents your stream from slowing\n            down due to slow write times.\n\n        Examples\n        --------\n        &gt;&gt;&gt; obs = Observable.from_iterable([1, 2, 3])\n        &gt;&gt;&gt; await obs.to_file('data.txt')\n        \"\"\"\n\n        # lock to prevent multiple awaitables from writing at the same time\n        can_write = anyio.Semaphore(1)\n        buffer: list[str] = []\n\n        class AnonymousSubscriber(Subscriber[Any]):\n            def __init__(self) -&gt; None:\n                self.file_handlers: dict[Path, AsyncFile[str]] = {}\n\n            async def on_next(self, value: A) -&gt; Acknowledgement:\n                # Only open file ONCE when first value is received\n                if file_path not in self.file_handlers:\n                    # First time\n                    file_path.parent.touch(exist_ok=True)\n                    file = await anyio.open_file(file_path, mode=\"w\")\n                    self.file_handlers[file_path] = file\n                else:\n                    file = self.file_handlers[file_path]\n                async with can_write:\n                    buffer.append(serialize(value) + ('\\n' if write_newline else ''))\n                    if len(buffer) == write_every_n:\n                        await file.writelines(buffer)\n                return Acknowledgement.ok\n\n            async def on_error(self, error: Exception) -&gt; None:\n                file = self.file_handlers.get(file_path)\n                if file is not None:\n                    async with can_write:\n                        # Write the buffer\n                        await file.writelines(buffer)\n                        await file.aclose()\n                raise error\n\n            async def on_completed(self) -&gt; None:\n                file = self.file_handlers.get(file_path)\n                if file is not None:\n                    async with can_write:\n                        # Write the buffer\n                        await file.writelines(buffer)\n                        await file.aclose()\n                return None\n\n        new_subscriber = AnonymousSubscriber()\n\n        await self.subscribe(new_subscriber)\n\n    async def reduce(self, func: Callable[[A, A], A], initial: A) -&gt; A:\n        \"\"\"Reduce the Observable using `func`, starting with `initial`.\n\n        Parameters\n        ----------\n        func : Callable[[A, A], A]\n            Function to apply to accumulate values.\n        initial : A\n            Initial value to start reduction from.\n\n        Returns\n        -------\n        A\n            Final accumulated reduction value.\n\n        Examples\n        --------\n        &gt;&gt;&gt; obs = Observable.from_iterable([1, 2, 3])\n        &gt;&gt;&gt; await obs.reduce(lambda acc, x: acc + x, 0)\n        6\n        \"\"\"\n        result = initial\n\n        async def on_next(value: A) -&gt; Acknowledgement:\n            nonlocal result\n            result = func(result, value)\n            return Acknowledgement.ok\n\n        reduce_subscriber = create_subscriber(on_next=on_next, on_completed=None, on_error=None)\n\n        await self.subscribe(reduce_subscriber)\n\n        return result\n\n    async def sum(self: 'Observable[int | float]') -&gt; int | float:\n        \"\"\"Sum all emitted values.\n\n        Returns\n        -------\n        int | float\n            Sum of all emitted values.\n\n        Examples\n        --------\n        &gt;&gt;&gt; obs = Observable.from_iterable([1, 2, 3])\n        &gt;&gt;&gt; await obs.sum()\n        6\n        \"\"\"\n        return await self.reduce(lambda a, b: a + b, 0)\n\n    async def sum_option(self: \"Observable[CanAdd]\") -&gt; Optional[CanAdd]:\n        \"\"\"Sum values using +, return None if empty.\n\n        Returns\n        -------\n        Optional[CanAdd]\n            Sum of values or None if empty.\n\n        Examples\n        --------\n        &gt;&gt;&gt; obs = Observable.from_iterable([1, 2, 3])\n        &gt;&gt;&gt; await obs.sum_option()\n        6\n        &gt;&gt;&gt; empty = Observable.from_iterable([])\n        &gt;&gt;&gt; await empty.sum_option()\n        None\n        \"\"\"\n        result = None\n\n        async def on_next(value: CanAdd) -&gt; Acknowledgement:\n            nonlocal result\n            result = value if result is None else result + value\n            return Acknowledgement.ok\n\n        reduce_subscriber = create_subscriber(on_next=on_next, on_completed=None, on_error=None)\n\n        await self.subscribe(reduce_subscriber)\n\n        return result\n\n    async def sum_or_raise(self: \"Observable[CanAdd]\") -&gt; CanAdd:\n        \"\"\"Sum values using +, raise if empty.\n\n        Raises\n        ------\n        GrugSumError\n            If the Observable is empty.\n\n        Returns\n        -------\n        CanAdd\n            Sum of values.\n\n        Examples\n        --------\n        &gt;&gt;&gt; obs = Observable.from_iterable([1, 2, 3])\n        &gt;&gt;&gt; await obs.sum_or_raise()\n        6\n        &gt;&gt;&gt; empty = Observable.from_iterable([])\n        &gt;&gt;&gt; await empty.sum_or_raise()\n        # raises GrugSumError\n        \"\"\"\n        result = await self.sum_option()\n        if result is None:\n            raise GrugSumError(\"Cannot sum an empty observable\")\n        return result\n\n    def take(self: Observable[A], n: int) -&gt; 'Observable[A]':\n        \"\"\"Take the first n values from the Observable.\n\n        Parameters\n        ----------\n        n : int\n            Number of values to take.\n\n        Returns\n        -------\n        Observable\n            Observable emitting the first n values.\n\n        Examples\n        --------\n        &gt;&gt;&gt; obs = Observable.from_iterable([1, 2, 3, 4, 5])\n        &gt;&gt;&gt; taken = obs.take(3)\n        &gt;&gt;&gt; await taken.to_list()\n        [1, 2, 3]\n        \"\"\"\n        source = self\n\n        async def subscribe_async(subscriber: Subscriber[A]) -&gt; None:\n            count = 0\n\n            async def on_next(value: A) -&gt; Acknowledgement:\n                nonlocal count\n                count += 1\n                if count &lt; n:\n                    return await subscriber.on_next(value)\n                else:\n                    # call on_completed when maximum count is reached\n                    # Call on_next one last time\n                    await subscriber.on_next(value)\n                    # Call on_completed\n                    await subscriber.on_completed()\n                    return Acknowledgement.stop\n\n            take_subscriber = create_subscriber(\n                on_next=on_next, on_error=subscriber.on_error, on_completed=subscriber.on_completed\n            )\n\n            await source.subscribe(take_subscriber)\n\n        return create_observable(subscribe_async)\n\n    def take_while_exclusive(self: Observable[A], predicate: Callable[[A], bool]) -&gt; 'Observable[A]':\n        \"\"\"Take values until predicate is false.\n\n        Stops **before** emitting the first value where `predicate` is false.\n\n        Parameters\n        ----------\n        predicate : Callable\n            Function to test each value.\n\n        Returns\n        -------\n        Observable\n            Observable emitting values until predicate is false.\n\n        Examples\n        --------\n        &gt;&gt;&gt; obs = Observable.from_iterable([1, 2, 3, 4, 5])\n        &gt;&gt;&gt; taken = obs.take_while_exclusive(lambda x: x &lt; 4)\n        &gt;&gt;&gt; await taken.to_list()\n        [1, 2, 3]\n        \"\"\"\n        source = self\n\n        async def subscribe_async(subscriber: Subscriber[A]) -&gt; None:\n            async def on_next(value: A) -&gt; Acknowledgement:\n                if predicate(value):\n                    return await subscriber.on_next(value)\n                else:\n                    # call on_completed when predicate violated\n                    await subscriber.on_completed()\n                    return Acknowledgement.stop\n\n            take_subscriber = create_subscriber(\n                on_next=on_next, on_error=subscriber.on_error, on_completed=subscriber.on_completed\n            )\n\n            await source.subscribe(take_subscriber)\n\n        return create_observable(subscribe_async)\n\n    def take_while_inclusive(self: Observable[A], predicate: Callable[[A], bool]) -&gt; 'Observable[A]':\n        \"\"\"Take values until predicate is false.\n\n        Stops **after** emitting the last value where `predicate` is true.\n\n        Parameters\n        ----------\n        predicate : Callable\n            Function to test each value.\n\n        Returns\n        -------\n        Observable\n            Observable emitting values until predicate is false.\n\n        Examples\n        --------\n        &gt;&gt;&gt; obs = Observable.from_iterable([1, 2, 3, 4, 5])\n        &gt;&gt;&gt; taken = obs.take_while_inclusive(lambda x: x &lt; 4)\n        &gt;&gt;&gt; await taken.to_list()\n        [1, 2, 3, 4]\n        \"\"\"\n        source = self\n\n        async def subscribe_async(subscriber: Subscriber[A]) -&gt; None:\n            async def on_next(value: A) -&gt; Acknowledgement:\n                if predicate(value):\n                    return await subscriber.on_next(value)\n                else:\n                    # include the violating element in the stream\n                    await subscriber.on_next(value)\n                    # call on_completed when predicate violated\n                    await subscriber.on_completed()\n                    return Acknowledgement.stop\n\n            take_subscriber = create_subscriber(\n                on_next=on_next, on_error=subscriber.on_error, on_completed=subscriber.on_completed\n            )\n\n            await source.subscribe(take_subscriber)\n\n        return create_observable(subscribe_async)\n\n    def take_last(self: Observable[A], n: int) -&gt; 'Observable[A]':\n        \"\"\"Take the last n values from the Observable.\n\n        Parameters\n        ----------\n        n : int\n            Number of last values to take.\n\n        Returns\n        -------\n        Observable\n            Observable emitting the last n values.\n\n        Examples\n        --------\n        &gt;&gt;&gt; obs = Observable.from_iterable([1, 2, 3, 4, 5])\n        &gt;&gt;&gt; taken = obs.take_last(2)\n        &gt;&gt;&gt; await taken.to_list()\n        [4, 5]\n        \"\"\"\n        source = self\n        buffer = deque(maxlen=n)\n\n        async def subscribe_async(subscriber: Subscriber[A]) -&gt; None:\n            async def on_next(value: A) -&gt; Acknowledgement:\n                buffer.append(value)\n                return Acknowledgement.ok\n\n            async def on_completed() -&gt; None:\n                for item in buffer:\n                    await subscriber.on_next(item)\n                await subscriber.on_completed()\n\n            take_last_subscriber = create_subscriber(\n                on_next=on_next,\n                on_completed=on_completed,\n                on_error=subscriber.on_error,\n            )\n\n            await source.subscribe(take_last_subscriber)\n\n        return create_observable(subscribe_async)\n\n    async def first(self) -&gt; A_co:\n        \"\"\"Get the first emitted value from the Observable.\n\n        Returns\n        -------\n        A_co\n            The first value emitted, or raises if empty.\n\n        Examples\n        --------\n        &gt;&gt;&gt; obs = Observable.from_iterable([1, 2, 3])\n        &gt;&gt;&gt; await obs.first()\n        1\n        \"\"\"\n        items = await self.take(1).to_list()\n        return items[0]\n\n    async def run_to_completion(self) -&gt; int:\n        \"\"\"Run the Observable and count emitted values.\n\n        Runs the Observable until completion, counting the\n        number of final values emitted.\n\n        Returns\n        -------\n        int\n            Number of values emitted before completion.\n\n        Examples\n        --------\n        &gt;&gt;&gt; obs = Observable.from_iterable([1, 2, 3]).take(2)\n        &gt;&gt;&gt; await obs.run_to_completion()\n        2\n        \"\"\"\n        count = 0\n\n        async def on_next(value: Any) -&gt; Acknowledgement:\n            nonlocal count\n            count = count + 1\n            return Acknowledgement.ok\n\n        subscriber = create_subscriber(on_next=on_next, on_completed=None, on_error=None)\n\n        await self.subscribe(subscriber)\n\n        return count\n\n    async def run_until_timeout(self, seconds: float) -&gt; int:\n        \"\"\"Run the Observable until a timeout occurs.\n\n        Runs the Observable until `seconds` elapse, counting the\n        number of values emitted in that time.\n\n        Parameters\n        ----------\n        seconds : float\n            Number of seconds to run for.\n\n        Returns\n        -------\n        int\n            Count of values emitted before timeout.\n\n        Examples\n        --------\n        &gt;&gt;&gt; obs = Observable.from_interval(0.1)\n        &gt;&gt;&gt; await obs.run_until_timeout(0.3)\n        # Emits ~3 values in 0.3 seconds\n        \"\"\"\n        count = 0\n\n        class AnonymousSubscriber(Subscriber[A]):\n            async def on_next(self, value: A) -&gt; Acknowledgement:\n                nonlocal count\n                count = count + 1\n                return Acknowledgement.ok\n\n            async def on_error(self, error: Exception) -&gt; None:\n                task_group.cancel_scope.cancel()\n                raise error\n\n            async def on_completed(self) -&gt; None:\n                task_group.cancel_scope.cancel()\n\n        subscriber = AnonymousSubscriber()\n\n        async def timeout_task():\n            await anyio.sleep(seconds)\n            task_group.cancel_scope.cancel()\n\n        async with create_task_group() as tg:\n            task_group = tg  # Set the task_group so we can cancel it in other methods\n            tg.start_soon(self.subscribe, subscriber)\n            tg.start_soon(timeout_task)\n\n        return count\n</code></pre>"},{"location":"2_observable_methods/#grugstream.core.Observable.buffer_with_size","title":"<code>buffer_with_size(max_buffer_size=100000)</code>","text":"<p>Adds a buffer to the stream</p> <p>Parameters:</p> Name Type Description Default <code>max_buffer_size</code> <code>int</code> <p>Max size of buffer for pending values. If None is passed, an infinite buffer is created.</p> <code>100000</code> Source code in <code>grugstream/core.py</code> <pre><code>def buffer_with_size(self: Observable[A], max_buffer_size: int | None = 100_000) -&gt; 'Observable[A]':\n    \"\"\"Adds a buffer to the stream\n\n    Parameters\n    ----------\n    max_buffer_size : int, optional\n        Max size of buffer for pending values. If None is passed, an infinite buffer is created.\n    \"\"\"\n\n    async def process_with_function(\n        subscriber: Subscriber[A], tg: TaskGroup, receive_stream: MemoryObjectReceiveStream[A]\n    ) -&gt; None:\n        async def process_item(item: A) -&gt; None:\n            ack = await subscriber.on_next(item)\n            if ack == Acknowledgement.stop:\n                tg.cancel_scope.cancel()\n\n        async for item in receive_stream:\n            tg.start_soon(process_item, item)\n\n    async def subscribe_async(subscriber: Subscriber[A]) -&gt; None:\n        send_stream, receive_stream = create_memory_object_stream(\n            max_buffer_size=max_buffer_size if max_buffer_size is not None else math.inf\n        )\n        try:\n\n            async def on_next(value: A) -&gt; Acknowledgement:\n                await send_stream.send(value)\n                return Acknowledgement.ok\n\n            async def on_completed() -&gt; None:\n                await send_stream.aclose()\n\n            send_to_stream_subscriber = create_subscriber(\n                on_next=on_next, on_completed=on_completed, on_error=subscriber.on_error\n            )\n\n            async with create_task_group() as tg:\n                tg.start_soon(self.subscribe, send_to_stream_subscriber)\n                tg.start_soon(process_with_function, subscriber, tg, receive_stream)\n            await subscriber.on_completed()\n\n        except Exception as e:\n            await subscriber.on_error(e)\n        finally:\n            await send_stream.aclose()\n\n    return create_observable(subscribe_async)\n</code></pre>"},{"location":"2_observable_methods/#grugstream.core.Observable.distinct","title":"<code>distinct()</code>","text":"<p>Filter Observable to only emit distinct values.</p> <p>Items are compared directly for uniqueness. Note that this requires items to implement hash. This uses a set to track seen hashes, so it will use O(n) memory, but should not be that much since it only stores hashes.</p> <p>Returns:</p> Type Description <code>Observable</code> <p>Observable that contains items that implement hash.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; obs = Observable.from_iterable([1, 2, 2, 3, 3, 1])\n&gt;&gt;&gt; distinct = obs.distinct()\n&gt;&gt;&gt; await distinct.to_list()\n[1, 2, 3]\n</code></pre> Source code in <code>grugstream/core.py</code> <pre><code>def distinct(self: 'Observable[CanHash]') -&gt; 'Observable[CanHash]':\n    \"\"\"Filter Observable to only emit distinct values.\n\n    Items are compared directly for uniqueness.\n    Note that this requires items to implement __hash__.\n    This uses a set to track seen hashes, so it will use O(n) memory,\n    but should not be that much since it only stores hashes.\n\n    Returns\n    -------\n    Observable\n        Observable that contains items that implement __hash__.\n\n    Examples\n    --------\n    &gt;&gt;&gt; obs = Observable.from_iterable([1, 2, 2, 3, 3, 1])\n    &gt;&gt;&gt; distinct = obs.distinct()\n    &gt;&gt;&gt; await distinct.to_list()\n    [1, 2, 3]\n    \"\"\"\n    return self.distinct_by(lambda x: x)\n</code></pre>"},{"location":"2_observable_methods/#grugstream.core.Observable.distinct_by","title":"<code>distinct_by(key)</code>","text":"<p>Filter Observable to only emit values with distinct keys.</p> <p>Items with different keys are considered distinct. This uses a set to track seen hashes, so it will use O(n) memory, but should not be that much since it only stores hashes.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Callable</code> <p>Function to extract comparison key for each item.</p> required <p>Returns:</p> Type Description <code>Observable</code> <p>Observable of items with distinct keys.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; obs = Observable.from_iterable([{'id': 1}, {'id': 2}, {'id': 1}])\n&gt;&gt;&gt; distinct = obs.distinct_by(lambda x: x['id'])\n&gt;&gt;&gt; await distinct.to_list()\n[{'id': 1}, {'id': 2}]\n</code></pre> Source code in <code>grugstream/core.py</code> <pre><code>def distinct_by(self: 'Observable[A]', key: Callable[[A], CanHash]) -&gt; 'Observable[A_co]':\n    \"\"\"Filter Observable to only emit values with distinct keys.\n\n    Items with different keys are considered distinct.\n    This uses a set to track seen hashes, so it will use O(n) memory,\n    but should not be that much since it only stores hashes.\n\n    Parameters\n    ----------\n    key : Callable\n        Function to extract comparison key for each item.\n\n    Returns\n    -------\n    Observable\n        Observable of items with distinct keys.\n\n    Examples\n    --------\n    &gt;&gt;&gt; obs = Observable.from_iterable([{'id': 1}, {'id': 2}, {'id': 1}])\n    &gt;&gt;&gt; distinct = obs.distinct_by(lambda x: x['id'])\n    &gt;&gt;&gt; await distinct.to_list()\n    [{'id': 1}, {'id': 2}]\n    \"\"\"\n    seen = set[CanHash]()\n\n    async def subscribe_async(subscriber: Subscriber[A]) -&gt; None:\n        async def on_next(value: A) -&gt; Acknowledgement:\n            try:\n                hashable_value = key(value)\n                if hashable_value not in seen:\n                    seen.add(hashable_value)\n                    return await subscriber.on_next(value)\n                return Acknowledgement.ok\n            except Exception as e:\n                await subscriber.on_error(e)\n                return Acknowledgement.stop\n\n        distinct_subscriber = create_subscriber(\n            on_next=on_next, on_error=subscriber.on_error, on_completed=subscriber.on_completed\n        )\n\n        await self.subscribe(distinct_subscriber)\n\n    return create_observable(subscribe_async)\n</code></pre>"},{"location":"2_observable_methods/#grugstream.core.Observable.enumerated","title":"<code>enumerated()</code>","text":"<p>Enumerate the values emitted by this Observable.</p> <p>Returns:</p> Type Description <code>Observable</code> <p>An Observable of (index, value) tuples.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; obs = Observable.from_iterable(['a', 'b', 'c'])\n&gt;&gt;&gt; enumerated = obs.enumerated()\n&gt;&gt;&gt; await enumerated.to_list()\n[(0, 'a'), (1, 'b'), (2, 'c')]\n</code></pre> Source code in <code>grugstream/core.py</code> <pre><code>def enumerated(self: Observable[A]) -&gt; \"Observable[tuple[int, A]]\":\n    \"\"\"Enumerate the values emitted by this Observable.\n\n    Returns\n    -------\n    Observable\n        An Observable of (index, value) tuples.\n\n    Examples\n    --------\n    &gt;&gt;&gt; obs = Observable.from_iterable(['a', 'b', 'c'])\n    &gt;&gt;&gt; enumerated = obs.enumerated()\n    &gt;&gt;&gt; await enumerated.to_list()\n    [(0, 'a'), (1, 'b'), (2, 'c')]\n\n    \"\"\"\n    source = self\n\n    async def subscribe(subscriber: Subscriber[tuple[int, A]]) -&gt; None:\n        counter = 0\n\n        async def on_next(value: A) -&gt; Acknowledgement:\n            nonlocal counter\n            idx = counter\n            transformed_value = (idx, value)\n            counter = counter + 1\n            return await subscriber.on_next(transformed_value)\n\n        map_subscriber = create_subscriber(\n            on_next=on_next, on_error=subscriber.on_error, on_completed=subscriber.on_completed\n        )\n\n        await source.subscribe(map_subscriber)\n\n    return create_observable(subscribe)\n</code></pre>"},{"location":"2_observable_methods/#grugstream.core.Observable.filter","title":"<code>filter(predicate)</code>","text":"<p>Filter values emitted by this Observable.</p> <p>Parameters:</p> Name Type Description Default <code>predicate</code> <code>callable</code> <p>The function to evaluate for each item.</p> required <p>Returns:</p> Type Description <code>Observable</code> <p>An Observable only emitting values where predicate is True.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; obs = Observable.from_iterable([1, 2, 3, 4])\n&gt;&gt;&gt; filtered = obs.filter(lambda x: x % 2 == 0)\n&gt;&gt;&gt; await filtered.to_list()\n[2, 4]\n</code></pre> Source code in <code>grugstream/core.py</code> <pre><code>def filter(self: Observable[A], predicate: Callable[[A], bool]) -&gt; \"Observable[A_co]\":\n    \"\"\"Filter values emitted by this Observable.\n\n    Parameters\n    ----------\n    predicate : callable\n        The function to evaluate for each item.\n\n    Returns\n    -------\n    Observable\n        An Observable only emitting values where predicate is True.\n\n    Examples\n    --------\n    &gt;&gt;&gt; obs = Observable.from_iterable([1, 2, 3, 4])\n    &gt;&gt;&gt; filtered = obs.filter(lambda x: x % 2 == 0)\n    &gt;&gt;&gt; await filtered.to_list()\n    [2, 4]\n\n    \"\"\"\n\n    async def new_subsribe_func(subscriber: Subscriber[A]) -&gt; None:\n        async def on_next(value: A) -&gt; Acknowledgement:\n            try:\n                if predicate(value):\n                    return await subscriber.on_next(value)\n            except Exception as e:\n                await subscriber.on_error(e)\n                return Acknowledgement.stop\n            return Acknowledgement.ok\n\n        filter_subscriber = create_subscriber(\n            on_next=on_next,\n            on_error=subscriber.on_error,\n            on_completed=subscriber.on_completed,\n        )\n        await self.subscribe(filter_subscriber)\n\n    return create_observable(new_subsribe_func)\n</code></pre>"},{"location":"2_observable_methods/#grugstream.core.Observable.first","title":"<code>first()</code>  <code>async</code>","text":"<p>Get the first emitted value from the Observable.</p> <p>Returns:</p> Type Description <code>A_co</code> <p>The first value emitted, or raises if empty.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; obs = Observable.from_iterable([1, 2, 3])\n&gt;&gt;&gt; await obs.first()\n1\n</code></pre> Source code in <code>grugstream/core.py</code> <pre><code>async def first(self) -&gt; A_co:\n    \"\"\"Get the first emitted value from the Observable.\n\n    Returns\n    -------\n    A_co\n        The first value emitted, or raises if empty.\n\n    Examples\n    --------\n    &gt;&gt;&gt; obs = Observable.from_iterable([1, 2, 3])\n    &gt;&gt;&gt; await obs.first()\n    1\n    \"\"\"\n    items = await self.take(1).to_list()\n    return items[0]\n</code></pre>"},{"location":"2_observable_methods/#grugstream.core.Observable.flatten_async_iterable","title":"<code>flatten_async_iterable()</code>","text":"<p>Flatten an Observable of async iterables into an Observable of values.</p> <p>Flattens an Observable of nested async iterables into a single Observable emitting all the nested values.</p> <p>Returns:</p> Type Description <code>Observable[A]</code> <p>Observable emitting all values from nested async iterables.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; async def gen(x):\n&gt;&gt;&gt;     yield x\n&gt;&gt;&gt; obs = Observable.from_iterable([gen(1), gen(2)])\n&gt;&gt;&gt; flattened = obs.flatten_async_iterable()\n&gt;&gt;&gt; await flattened.to_list()\n[1, 2]\n</code></pre> Source code in <code>grugstream/core.py</code> <pre><code>def flatten_async_iterable(self: 'Observable[AsyncIterable[A]]') -&gt; 'Observable[A]':\n    \"\"\"Flatten an Observable of async iterables into an Observable of values.\n\n    Flattens an Observable of nested async iterables into a single\n    Observable emitting all the nested values.\n\n    Returns\n    -------\n    Observable[A]\n        Observable emitting all values from nested async iterables.\n\n    Examples\n    --------\n    &gt;&gt;&gt; async def gen(x):\n    &gt;&gt;&gt;     yield x\n    &gt;&gt;&gt; obs = Observable.from_iterable([gen(1), gen(2)])\n    &gt;&gt;&gt; flattened = obs.flatten_async_iterable()\n    &gt;&gt;&gt; await flattened.to_list()\n    [1, 2]\n    \"\"\"\n\n    return self.map(Observable.from_async_iterable).flatten_observable()\n</code></pre>"},{"location":"2_observable_methods/#grugstream.core.Observable.flatten_iterable","title":"<code>flatten_iterable()</code>","text":"<p>Flatten an Observable of iterables into an Observable of values.</p> <p>Flattens an Observable of nested iterables into a single Observable emitting all the nested values.</p> <p>Returns:</p> Type Description <code>Observable[A]</code> <p>Observable emitting all values from nested iterables.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; obs = Observable.from_iterable([[1, 2], [3, 4]])\n&gt;&gt;&gt; flattened = obs.flatten_iterable()\n&gt;&gt;&gt; await flattened.to_list()\n[1, 2, 3, 4]\n</code></pre> Source code in <code>grugstream/core.py</code> <pre><code>def flatten_iterable(self: 'Observable[Iterable[A]]') -&gt; 'Observable[A]':\n    \"\"\"Flatten an Observable of iterables into an Observable of values.\n\n    Flattens an Observable of nested iterables into a single\n    Observable emitting all the nested values.\n\n    Returns\n    -------\n    Observable[A]\n        Observable emitting all values from nested iterables.\n\n    Examples\n    --------\n    &gt;&gt;&gt; obs = Observable.from_iterable([[1, 2], [3, 4]])\n    &gt;&gt;&gt; flattened = obs.flatten_iterable()\n    &gt;&gt;&gt; await flattened.to_list()\n    [1, 2, 3, 4]\n    \"\"\"\n\n    async def subscribe_async(subscriber: Subscriber[A]) -&gt; None:\n        async def on_next(iterable: Iterable[A]) -&gt; Acknowledgement:\n            for item in iterable:\n                ack = await subscriber.on_next(item)\n                if ack == Acknowledgement.stop:\n                    return Acknowledgement.stop\n            return Acknowledgement.ok\n\n        flatten_subscriber = create_subscriber(\n            on_next=on_next, on_error=subscriber.on_error, on_completed=subscriber.on_completed\n        )\n\n        await self.subscribe(flatten_subscriber)\n\n    return create_observable(subscribe_async)\n</code></pre>"},{"location":"2_observable_methods/#grugstream.core.Observable.flatten_list","title":"<code>flatten_list()</code>","text":"<p>Flatten an Observable of lists into an Observable of values.</p> Source code in <code>grugstream/core.py</code> <pre><code>def flatten_list(self: 'Observable[Sequence[A]]') -&gt; 'Observable[A]':\n    \"\"\"Flatten an Observable of lists into an Observable of values.\"\"\"\n    return self.flatten_iterable()\n</code></pre>"},{"location":"2_observable_methods/#grugstream.core.Observable.flatten_observable","title":"<code>flatten_observable()</code>","text":"<p>Flatten Observable of Observables into one Observable.</p> <p>Flattens an Observable emitting other Observables, into a single Observable emitting all the values from the nested Observables. Note that this will try to emit values from the nested Observables concurrently.</p> <p>Returns:</p> Type Description <code>Observable[B]</code> <p>Observable emitting all values from nested Observables.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; obs1 = Observable.from_iterable([1, 2])\n&gt;&gt;&gt; obs2 = Observable.from_iterable([3, 4])\n&gt;&gt;&gt; outer = Observable.from_iterable([obs1, obs2])\n&gt;&gt;&gt; flattened = outer.flatten_observable()\n&gt;&gt;&gt; await flattened.to_list()\n[1, 3, 4, 2]\n</code></pre> Source code in <code>grugstream/core.py</code> <pre><code>def flatten_observable(self: 'Observable[Observable[B]]') -&gt; 'Observable[B]':\n    \"\"\"Flatten Observable of Observables into one Observable.\n\n    Flattens an Observable emitting other Observables, into a single\n    Observable emitting all the values from the nested Observables.\n    Note that this will try to emit values from the nested Observables\n    concurrently.\n\n\n    Returns\n    -------\n    Observable[B]\n        Observable emitting all values from nested Observables.\n\n    Examples\n    --------\n    &gt;&gt;&gt; obs1 = Observable.from_iterable([1, 2])\n    &gt;&gt;&gt; obs2 = Observable.from_iterable([3, 4])\n    &gt;&gt;&gt; outer = Observable.from_iterable([obs1, obs2])\n    &gt;&gt;&gt; flattened = outer.flatten_observable()\n    &gt;&gt;&gt; await flattened.to_list()\n    [1, 3, 4, 2]\n    \"\"\"\n\n    async def subscribe_async(subscriber: Subscriber[B]) -&gt; None:\n        async def subscribe_inner(inner_observable: Observable[B]) -&gt; None:\n            async def on_next(value: B) -&gt; Acknowledgement:\n                ack = await subscriber.on_next(value)\n                if ack == Acknowledgement.stop:\n                    tg.cancel_scope.cancel()\n                return ack\n\n            async def on_error(e: Exception) -&gt; None:\n                tg.cancel_scope.cancel()\n                await subscriber.on_error(e)\n\n            async def on_completed() -&gt; None:\n                await subscriber.on_completed()\n\n            await inner_observable.subscribe(\n                create_subscriber(on_next=on_next, on_error=on_error, on_completed=on_completed)\n            )\n\n        async with anyio.create_task_group() as tg:\n            async for inner_observable in self.to_async_iterable():\n                tg.start_soon(subscribe_inner, inner_observable)\n\n    return create_observable(subscribe_async)\n</code></pre>"},{"location":"2_observable_methods/#grugstream.core.Observable.flatten_observable_sequential","title":"<code>flatten_observable_sequential()</code>","text":"<p>Flatten Observable of Observables into one Observable.</p> <p>Flattens an Observable emitting other Observables, into a single Observable emitting all the values from the nested Observables. Note that this outputs values from the nested Observables in sequential order.</p> <p>Returns:</p> Type Description <code>Observable[B]</code> <p>Observable emitting all values from nested Observables.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; obs1 = Observable.from_iterable([1, 2])\n&gt;&gt;&gt; obs2 = Observable.from_iterable([3, 4])\n&gt;&gt;&gt; outer = Observable.from_iterable([obs1, obs2])\n&gt;&gt;&gt; flattened = outer.flatten_observable()\n&gt;&gt;&gt; await flattened.to_list()\n[1, 2, 3, 4]\n</code></pre> Source code in <code>grugstream/core.py</code> <pre><code>def flatten_observable_sequential(self: 'Observable[Observable[B]]') -&gt; 'Observable[B]':\n    \"\"\"Flatten Observable of Observables into one Observable.\n\n    Flattens an Observable emitting other Observables, into a single\n    Observable emitting all the values from the nested Observables.\n    Note that this outputs values from the nested Observables in\n    sequential order.\n\n    Returns\n    -------\n    Observable[B]\n        Observable emitting all values from nested Observables.\n\n    Examples\n    --------\n    &gt;&gt;&gt; obs1 = Observable.from_iterable([1, 2])\n    &gt;&gt;&gt; obs2 = Observable.from_iterable([3, 4])\n    &gt;&gt;&gt; outer = Observable.from_iterable([obs1, obs2])\n    &gt;&gt;&gt; flattened = outer.flatten_observable()\n    &gt;&gt;&gt; await flattened.to_list()\n    [1, 2, 3, 4]\n    \"\"\"\n\n    async def subscribe_async(subscriber: Subscriber[B]) -&gt; None:\n        async def on_inner_next(value: B) -&gt; Acknowledgement:\n            return await subscriber.on_next(value)\n\n        async def on_next(inner_observable: Observable[B]) -&gt; Acknowledgement:\n            inner_subscriber = create_subscriber(\n                on_next=on_inner_next, on_error=subscriber.on_error, on_completed=subscriber.on_completed\n            )\n            await inner_observable.subscribe(inner_subscriber)\n            return Acknowledgement.ok\n\n        flatten_subscriber = create_subscriber(\n            on_next=on_next, on_error=subscriber.on_error, on_completed=subscriber.on_completed\n        )\n\n        await self.subscribe(flatten_subscriber)\n\n    return create_observable(subscribe_async)\n</code></pre>"},{"location":"2_observable_methods/#grugstream.core.Observable.flatten_optional","title":"<code>flatten_optional()</code>","text":"<p>Flatten an Observable of Optional values into an Observable of present values.</p> <p>Flattens an Observable of Optional values, removing any None values.</p> <p>Returns:</p> Type Description <code>Observable[A]</code> <p>Observable only emitting present values, removing any Nones.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; obs = Observable.from_iterable([1, None, 2, None, 3])\n&gt;&gt;&gt; flattened = obs.flatten_optional()\n&gt;&gt;&gt; await flattened.to_list()\n[1, 2, 3]\n</code></pre> Source code in <code>grugstream/core.py</code> <pre><code>def flatten_optional(self: 'Observable[A | None]') -&gt; 'Observable[A]':\n    \"\"\"Flatten an Observable of Optional values into an Observable of present values.\n\n    Flattens an Observable of Optional values, removing any None values.\n\n    Returns\n    -------\n    Observable[A]\n        Observable only emitting present values, removing any Nones.\n\n    Examples\n    --------\n    &gt;&gt;&gt; obs = Observable.from_iterable([1, None, 2, None, 3])\n    &gt;&gt;&gt; flattened = obs.flatten_optional()\n    &gt;&gt;&gt; await flattened.to_list()\n    [1, 2, 3]\n    \"\"\"\n\n    async def subscribe_async(subscriber: Subscriber[A]) -&gt; None:\n        async def on_next(value: A | None) -&gt; Acknowledgement:\n            if value is not None:\n                return await subscriber.on_next(value)\n            return Acknowledgement.ok\n\n        flatten_subscriber = create_subscriber(\n            on_next=on_next, on_error=subscriber.on_error, on_completed=subscriber.on_completed\n        )\n\n        await self.subscribe(flatten_subscriber)\n\n    return create_observable(subscribe_async)\n</code></pre>"},{"location":"2_observable_methods/#grugstream.core.Observable.for_each","title":"<code>for_each(func)</code>","text":"<p>Apply func to each value but don't modify stream.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable</code> <p>Function to apply to each value.</p> required <p>Returns:</p> Type Description <code>Observable</code> <p>Output Observable with values unchanged.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; obs = Observable.from_iterable([1, 2, 3])\n&gt;&gt;&gt; obs.for_each(print).to_list()\n1\n2\n3\n[1, 2, 3]\n</code></pre> Source code in <code>grugstream/core.py</code> <pre><code>def for_each(self: Observable[A], func: Callable[[A], Any]) -&gt; \"Observable[A]\":\n    \"\"\"Apply func to each value but don't modify stream.\n\n    Parameters\n    ----------\n    func : Callable\n        Function to apply to each value.\n\n    Returns\n    -------\n    Observable\n        Output Observable with values unchanged.\n\n    Examples\n    --------\n    &gt;&gt;&gt; obs = Observable.from_iterable([1, 2, 3])\n    &gt;&gt;&gt; obs.for_each(print).to_list()\n    1\n    2\n    3\n    [1, 2, 3]\n    \"\"\"\n\n    def return_original(value: A) -&gt; A:\n        func(value)\n        return value\n\n    return self.map(return_original)\n</code></pre>"},{"location":"2_observable_methods/#grugstream.core.Observable.for_each_async","title":"<code>for_each_async(func)</code>","text":"<p>Apply asynchronous func to each value.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable</code> <p>Asynchronous function to apply.</p> required <p>Returns:</p> Type Description <code>Observable</code> <p>Output Observable with values unchanged.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; async def print_delayed(x):\n&gt;&gt;&gt;     await asyncio.sleep(1)\n&gt;&gt;&gt;     print(x)\n&gt;&gt;&gt;\n&gt;&gt;&gt; obs = Observable.from_iterable([1, 2, 3])\n&gt;&gt;&gt; obs.for_each_async(print_delayed).to_list()\n1    # printed after 1 second\n2    # printed after 1 more second\n3\n[1, 2, 3]\n</code></pre> Source code in <code>grugstream/core.py</code> <pre><code>def for_each_async(self: Observable[A], func: Callable[[A], Awaitable[None]]) -&gt; \"Observable[A]\":\n    \"\"\"Apply asynchronous func to each value.\n\n    Parameters\n    ----------\n    func : Callable\n        Asynchronous function to apply.\n\n    Returns\n    -------\n    Observable\n        Output Observable with values unchanged.\n\n    Examples\n    --------\n    &gt;&gt;&gt; async def print_delayed(x):\n    &gt;&gt;&gt;     await asyncio.sleep(1)\n    &gt;&gt;&gt;     print(x)\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; obs = Observable.from_iterable([1, 2, 3])\n    &gt;&gt;&gt; obs.for_each_async(print_delayed).to_list()\n    1    # printed after 1 second\n    2    # printed after 1 more second\n    3\n    [1, 2, 3]\n    \"\"\"\n\n    async def return_original(value: A) -&gt; A:\n        await func(value)\n        return value\n\n    return self.map_async(return_original)\n</code></pre>"},{"location":"2_observable_methods/#grugstream.core.Observable.for_each_count","title":"<code>for_each_count(counter, key=lambda x: 'count')</code>","text":"<p>Increment counter for each value.</p> <p>Parameters:</p> Name Type Description Default <code>counter</code> <code>Counter</code> <p>The counter to increment.</p> required <code>key</code> <code>Callable</code> <p>Function to get the key to increment, by default lambda x: x['count']</p> <code>lambda x: 'count'</code> <p>Returns:</p> Type Description <code>Observable</code> <p>Output Observable with values unchanged.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; counter = Counter()\n&gt;&gt;&gt; obs = Observable.from_iterable([1,2,3])\n&gt;&gt;&gt; obs.for_each_count(counter).run_to_completion()\n&gt;&gt;&gt; counter\nCounter({\"count\": 1})\n</code></pre> Source code in <code>grugstream/core.py</code> <pre><code>def for_each_count(\n    self: Observable[A], counter: Counter[Any], key: Callable[[A], CanHash] = lambda x: \"count\"\n) -&gt; \"Observable[A]\":\n    \"\"\"Increment counter for each value.\n\n    Parameters\n    ----------\n    counter : Counter\n        The counter to increment.\n    key : Callable, optional\n        Function to get the key to increment, by default lambda x: x['count']\n\n    Returns\n    -------\n    Observable\n        Output Observable with values unchanged.\n\n    Examples\n    --------\n    &gt;&gt;&gt; counter = Counter()\n    &gt;&gt;&gt; obs = Observable.from_iterable([1,2,3])\n    &gt;&gt;&gt; obs.for_each_count(counter).run_to_completion()\n    &gt;&gt;&gt; counter\n    Counter({\"count\": 1})\n    \"\"\"\n\n    def counter_update(ele: A):\n        counter_key = key(ele)\n        counter[counter_key] += 1\n\n    return self.for_each(counter_update)\n</code></pre>"},{"location":"2_observable_methods/#grugstream.core.Observable.for_each_enumerated","title":"<code>for_each_enumerated(func)</code>","text":"<p>Apply indexed func to each value, but don't modify stream.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable</code> <p>Function accepting index and value.</p> required <p>Returns:</p> Type Description <code>Observable</code> <p>Output Observable with values unchanged.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; obs = Observable.from_iterable(['a', 'b', 'c'])\n&gt;&gt;&gt; obs.for_each_enumerated(lambda i, x: print(f'{i}: {x}')).to_list()\n0: a\n1: b\n2: c\n['a', 'b', 'c']\n</code></pre> Source code in <code>grugstream/core.py</code> <pre><code>def for_each_enumerated(self: Observable[A], func: Callable[[int, A], Any]) -&gt; \"Observable[A]\":\n    \"\"\"Apply indexed func to each value, but don't modify stream.\n\n    Parameters\n    ----------\n    func : Callable\n        Function accepting index and value.\n\n    Returns\n    -------\n    Observable\n        Output Observable with values unchanged.\n\n    Examples\n    --------\n    &gt;&gt;&gt; obs = Observable.from_iterable(['a', 'b', 'c'])\n    &gt;&gt;&gt; obs.for_each_enumerated(lambda i, x: print(f'{i}: {x}')).to_list()\n    0: a\n    1: b\n    2: c\n    ['a', 'b', 'c']\n    \"\"\"\n\n    def return_original(idx: int, value: A) -&gt; A:\n        func(idx, value)\n        return value\n\n    return self.enumerated().map_2(return_original)\n</code></pre>"},{"location":"2_observable_methods/#grugstream.core.Observable.for_each_to_file_appending","title":"<code>for_each_to_file_appending(file_path, serialize=str, write_newline=True)</code>","text":"<pre><code>    Pass through and appends to a file continuously\n</code></pre> <pre><code>    Parameters\n</code></pre> <pre><code>    file_path : Path\n        Path to write the file to.\n    serialize : Callable, default str\n        Function to serialize values to strings.\n    write_newline : bool, default True\n        Whether to write a newline after each value.\n</code></pre> <pre><code>    Returns\n</code></pre> <pre><code>    Observable\n        Output Observable with values unchanged.\n</code></pre> <pre><code>    Examples\n</code></pre> <pre><code>    &gt;&gt;&gt; obs = Observable.from_iterable([1, 2, 3])\n    &gt;&gt;&gt; await obs.for_each_to_file(Path('data.txt')).run_to_completion()\n    # data.txt will contain '1\n</code></pre> <p>2 3 '</p> Source code in <code>grugstream/core.py</code> <pre><code>def for_each_to_file_appending(\n    self: Observable[A],\n    file_path: Path,\n    serialize: Callable[[A], str] = str,\n    write_newline: bool = True,\n) -&gt; \"Observable[A]\":\n    \"\"\"\n    Pass through and appends to a file continuously\n\n    Parameters\n    ----------\n    file_path : Path\n        Path to write the file to.\n    serialize : Callable, default str\n        Function to serialize values to strings.\n    write_newline : bool, default True\n        Whether to write a newline after each value.\n\n    Returns\n    -------\n    Observable\n        Output Observable with values unchanged.\n\n    Examples\n    --------\n    &gt;&gt;&gt; obs = Observable.from_iterable([1, 2, 3])\n    &gt;&gt;&gt; await obs.for_each_to_file(Path('data.txt')).run_to_completion()\n    # data.txt will contain '1\\n2\\n3\\n'\n    \"\"\"\n\n    # need a lock to prevent multiple awaitable when it isn't ok to write yet\n    can_write = anyio.Semaphore(1)\n    source = self\n\n    async def next_subscriber(subscriber: Subscriber[A]) -&gt; None:\n        class AnonSubscriber(Subscriber[Any]):\n            def __init__(self) -&gt; None:\n                self.file_handlers: dict[Path, AsyncFile[str]] = {}\n\n            async def on_next(self, value: A) -&gt; Acknowledgement:\n                if file_path not in self.file_handlers:\n                    file_path.parent.mkdir(exist_ok=True, parents=True)\n                    file = await anyio.open_file(file_path, mode=\"a\")\n                    self.file_handlers[file_path] = file\n                else:\n                    file = self.file_handlers[file_path]\n                async with can_write:\n                    write_str = serialize(value) + ('\\n' if write_newline else '')\n                    await file.write(write_str)\n\n                return await subscriber.on_next(value)\n\n            async def on_error(self, error: Exception) -&gt; None:\n                file = self.file_handlers.get(file_path)\n                if file is not None:\n                    await file.aclose()\n                return await subscriber.on_error(error)\n\n            async def on_completed(self) -&gt; None:\n                file = self.file_handlers.get(file_path)\n                if file is not None:\n                    await file.aclose()\n                return await subscriber.on_completed()\n\n        await source.subscribe(AnonSubscriber())\n\n    return create_observable(next_subscriber)\n</code></pre>"},{"location":"2_observable_methods/#grugstream.core.Observable.for_each_to_list","title":"<code>for_each_to_list(collect_list)</code>","text":"<p>Append each value to a list.</p> <p>Parameters:</p> Name Type Description Default <code>collect_list</code> <code>list</code> <p>The list to append values to.</p> required <p>Returns:</p> Type Description <code>Observable</code> <p>Output Observable with values unchanged.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; my_list = []\n&gt;&gt;&gt; obs = Observable.from_iterable([1, 2, 3])\n&gt;&gt;&gt; obs.for_each_to_list(my_list).to_list()\n[1, 2, 3]\n&gt;&gt;&gt; my_list\n[1, 2, 3]\n</code></pre> Source code in <code>grugstream/core.py</code> <pre><code>def for_each_to_list(self: Observable[A], collect_list: list[A]) -&gt; \"Observable[A]\":\n    \"\"\"Append each value to a list.\n\n    Parameters\n    ----------\n    collect_list : list\n        The list to append values to.\n\n    Returns\n    -------\n    Observable\n        Output Observable with values unchanged.\n\n    Examples\n    --------\n    &gt;&gt;&gt; my_list = []\n    &gt;&gt;&gt; obs = Observable.from_iterable([1, 2, 3])\n    &gt;&gt;&gt; obs.for_each_to_list(my_list).to_list()\n    [1, 2, 3]\n    &gt;&gt;&gt; my_list\n    [1, 2, 3]\n    \"\"\"\n\n    def append_to_list(value: A) -&gt; A:\n        collect_list.append(value)\n        return value\n\n    return self.map(append_to_list)\n</code></pre>"},{"location":"2_observable_methods/#grugstream.core.Observable.for_each_to_stream","title":"<code>for_each_to_stream(stream)</code>","text":"<p>Send each value to a stream.</p> <p>Parameters:</p> Name Type Description Default <code>stream</code> <code>MemoryObjectSendStream</code> <p>The stream to send values to.</p> required <p>Returns:</p> Type Description <code>Observable</code> <p>Output Observable with values unchanged.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; send_stream, _ = create_memory_object_stream()\n&gt;&gt;&gt; obs = Observable.from_iterable([1, 2, 3])\n&gt;&gt;&gt; obs.for_each_to_stream(send_stream)\n&gt;&gt;&gt; # `send_stream` will have received the values\n</code></pre> Source code in <code>grugstream/core.py</code> <pre><code>def for_each_to_stream(self: Observable[A], stream: MemoryObjectSendStream[A]) -&gt; \"Observable[A]\":\n    \"\"\"Send each value to a stream.\n\n    Parameters\n    ----------\n    stream : MemoryObjectSendStream\n        The stream to send values to.\n\n    Returns\n    -------\n    Observable\n        Output Observable with values unchanged.\n\n    Examples\n    --------\n    &gt;&gt;&gt; send_stream, _ = create_memory_object_stream()\n    &gt;&gt;&gt; obs = Observable.from_iterable([1, 2, 3])\n    &gt;&gt;&gt; obs.for_each_to_stream(send_stream)\n    &gt;&gt;&gt; # `send_stream` will have received the values\n    \"\"\"\n\n    async def send(value: A) -&gt; A:\n        await stream.send(value)\n        return value\n\n    return self.map_async(send)\n</code></pre>"},{"location":"2_observable_methods/#grugstream.core.Observable.from_async_iterable","title":"<code>from_async_iterable(iterable)</code>  <code>staticmethod</code>","text":"<p>Create an Observable from an asynchronous iterable.</p> <p>Parameters:</p> Name Type Description Default <code>iterable</code> <code>AsyncIterable</code> <p>The asynchronous iterable to convert to an Observable.</p> required <p>Returns:</p> Type Description <code>Observable</code> <p>An Observable emitting values from the async iterable.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; async def gen():\n&gt;&gt;&gt;     yield 1\n&gt;&gt;&gt;     yield 2\n&gt;&gt;&gt; obs = Observable.from_async_iterable(gen())\n&gt;&gt;&gt; await obs.to_list()\n[1, 2]\n</code></pre> Source code in <code>grugstream/core.py</code> <pre><code>@staticmethod\ndef from_async_iterable(iterable: AsyncIterable[A]) -&gt; \"Observable[A]\":\n    \"\"\"Create an Observable from an asynchronous iterable.\n\n    Parameters\n    ----------\n    iterable : AsyncIterable\n        The asynchronous iterable to convert to an Observable.\n\n    Returns\n    -------\n    Observable\n        An Observable emitting values from the async iterable.\n\n    Examples\n    --------\n    &gt;&gt;&gt; async def gen():\n    &gt;&gt;&gt;     yield 1\n    &gt;&gt;&gt;     yield 2\n    &gt;&gt;&gt; obs = Observable.from_async_iterable(gen())\n    &gt;&gt;&gt; await obs.to_list()\n    [1, 2]\n    \"\"\"\n\n    class AsyncIterableObservable(Observable[B]):\n        async def subscribe(self, subscriber: Subscriber[A]) -&gt; None:\n            ack = Acknowledgement.ok\n            async for item in iterable:\n                if ack != Acknowledgement.ok:\n                    break\n                ack = await subscriber.on_next(item)\n            await subscriber.on_completed()\n\n    return AsyncIterableObservable()\n</code></pre>"},{"location":"2_observable_methods/#grugstream.core.Observable.from_async_iterable_thunk","title":"<code>from_async_iterable_thunk(thunk)</code>  <code>staticmethod</code>","text":"<p>Create an Observable from a thunk that returns an iterable. This is useful if you want to re-evaluate the iterable each time. For example, generators can only be iterated once, so you can use this to re-evaluate the generator each time.</p> <p>Parameters:</p> Name Type Description Default <code>thunk</code> <code>Callable</code> <p>The asynchronous iterable to convert to an Observable.</p> required <p>Returns:</p> Type Description <code>Observable</code> <p>An Observable emitting values from the async iterable.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; async def gen():\n&gt;&gt;&gt;     yield 1\n&gt;&gt;&gt;     yield 2\n&gt;&gt;&gt; obs = Observable.from_async_iterable_thunk(lambda: gen())\n&gt;&gt;&gt; await obs.to_list()\n[1, 2]\n&gt;&gt;&gt; await obs.to_list() # can be called multiple times, each time it will re-evaluate the thunk\n[1, 2]\n</code></pre> Source code in <code>grugstream/core.py</code> <pre><code>@staticmethod\ndef from_async_iterable_thunk(thunk: Callable[[], AsyncIterable[A]]) -&gt; \"Observable[A]\":\n    \"\"\"Create an Observable from a thunk that returns an iterable.\n    This is useful if you want to re-evaluate the iterable each time.\n    For example, generators can only be iterated once, so you can use this to\n    re-evaluate the generator each time.\n\n    Parameters\n    ----------\n    thunk : Callable\n        The asynchronous iterable to convert to an Observable.\n\n    Returns\n    -------\n    Observable\n        An Observable emitting values from the async iterable.\n\n    Examples\n    --------\n    &gt;&gt;&gt; async def gen():\n    &gt;&gt;&gt;     yield 1\n    &gt;&gt;&gt;     yield 2\n    &gt;&gt;&gt; obs = Observable.from_async_iterable_thunk(lambda: gen())\n    &gt;&gt;&gt; await obs.to_list()\n    [1, 2]\n    &gt;&gt;&gt; await obs.to_list() # can be called multiple times, each time it will re-evaluate the thunk\n    [1, 2]\n    \"\"\"\n\n    class AsyncIterableObservable(Observable[A]):  # type: ignore\n        async def subscribe(self, subscriber: Subscriber[A]) -&gt; None:\n            generator = thunk()\n            ack = Acknowledgement.ok\n            async for item in generator:\n                if ack != Acknowledgement.ok:\n                    break\n                ack = await subscriber.on_next(item)\n            await subscriber.on_completed()\n\n    return AsyncIterableObservable()\n</code></pre>"},{"location":"2_observable_methods/#grugstream.core.Observable.from_awaitable","title":"<code>from_awaitable(awaitable)</code>  <code>classmethod</code>","text":"<p>Create an Observable from an awaitable.</p> <p>Parameters:</p> Name Type Description Default <code>awaitable</code> <code>Awaitable[A]</code> <p>The awaitable to convert to an Observable.</p> required <p>Returns:</p> Type Description <code>Observable</code> <p>An Observable emitting the value from the awaitable.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; async def get_value():\n&gt;&gt;&gt;     return 10\n&gt;&gt;&gt; obs = Observable.from_awaitable(get_value())\n&gt;&gt;&gt; await obs.to_list()\n[10]\n</code></pre> Source code in <code>grugstream/core.py</code> <pre><code>@classmethod\ndef from_awaitable(cls, awaitable: Awaitable[A]) -&gt; \"Observable[A]\":\n    \"\"\"Create an Observable from an awaitable.\n\n    Parameters\n    ----------\n    awaitable :\n        The awaitable to convert to an Observable.\n\n    Returns\n    -------\n    Observable\n        An Observable emitting the value from the awaitable.\n\n    Examples\n    --------\n    &gt;&gt;&gt; async def get_value():\n    &gt;&gt;&gt;     return 10\n    &gt;&gt;&gt; obs = Observable.from_awaitable(get_value())\n    &gt;&gt;&gt; await obs.to_list()\n    [10]\n    \"\"\"\n\n    async def subscribe(subscriber: Subscriber[A]) -&gt; None:\n        value = await awaitable\n        await subscriber.on_next(value)\n        await subscriber.on_completed()\n\n    return create_observable(subscribe)\n</code></pre>"},{"location":"2_observable_methods/#grugstream.core.Observable.from_empty","title":"<code>from_empty()</code>  <code>classmethod</code>","text":"<p>Create an empty Observable that emits no items.</p> <p>Returns:</p> Type Description <code>Observable</code> <p>An Observable that emits no items and immediately completes.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; obs = Observable.from_empty()\n&gt;&gt;&gt; await obs.to_list()\n[]\n</code></pre> Source code in <code>grugstream/core.py</code> <pre><code>@classmethod\ndef from_empty(cls) -&gt; \"Observable[A]\":  # type: ignore\n    \"\"\"Create an empty Observable that emits no items.\n\n    Returns\n    -------\n    Observable\n        An Observable that emits no items and immediately completes.\n\n    Examples\n    --------\n    &gt;&gt;&gt; obs = Observable.from_empty()\n    &gt;&gt;&gt; await obs.to_list()\n    []\n    \"\"\"\n    return cls.from_iterable([])\n</code></pre>"},{"location":"2_observable_methods/#grugstream.core.Observable.from_file","title":"<code>from_file(file_path)</code>  <code>staticmethod</code>","text":"<p>Create an Observable that emits lines from a text file.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>Path</code> <p>Path to the text file.</p> required <p>Returns:</p> Type Description <code>Observable[str]</code> <p>An Observable emitting each line of the text file.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; obs = Observable.from_file('data.txt')\n&gt;&gt;&gt; await obs.take(3).to_list()\n['line1', 'line2', 'line3']\n</code></pre> Source code in <code>grugstream/core.py</code> <pre><code>@staticmethod\ndef from_file(file_path: Path) -&gt; \"Observable[str]\":\n    \"\"\"Create an Observable that emits lines from a text file.\n\n    Parameters\n    ----------\n    file_path : Path\n        Path to the text file.\n\n    Returns\n    -------\n    Observable[str]\n        An Observable emitting each line of the text file.\n\n    Examples\n    --------\n    &gt;&gt;&gt; obs = Observable.from_file('data.txt')\n    &gt;&gt;&gt; await obs.take(3).to_list()\n    ['line1', 'line2', 'line3']\n    \"\"\"\n\n    async def async_iterator() -&gt; AsyncIterable[str]:\n        async with await anyio.open_file(file_path) as f:\n            async for line in f:\n                line_without_newline = line.rstrip('\\n')\n                yield line_without_newline\n\n    return Observable.from_async_iterable_thunk(lambda: async_iterator())\n</code></pre>"},{"location":"2_observable_methods/#grugstream.core.Observable.from_interval","title":"<code>from_interval(seconds)</code>  <code>staticmethod</code>","text":"<p>Create an Observable emitting incremental numbers periodically.</p> <p>Emits an infinite sequence of incremental integers, with time period of <code>seconds</code> between each emission.</p> <p>Parameters:</p> Name Type Description Default <code>seconds</code> <code>float</code> <p>The interval in seconds between emissions.</p> required <p>Returns:</p> Type Description <code>Observable[int]</code> <p>An Observable emitting incremental numbers at fixed interval.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; obs = Observable.from_interval(1.0)\n&gt;&gt;&gt; await obs.take(3).to_list()\n[0, 1, 2]\n</code></pre> Source code in <code>grugstream/core.py</code> <pre><code>@staticmethod\ndef from_interval(seconds: float) -&gt; 'Observable[int]':\n    \"\"\"Create an Observable emitting incremental numbers periodically.\n\n    Emits an infinite sequence of incremental integers, with time\n    period of `seconds` between each emission.\n\n    Parameters\n    ----------\n    seconds : float\n        The interval in seconds between emissions.\n\n    Returns\n    -------\n    Observable[int]\n        An Observable emitting incremental numbers at fixed interval.\n\n    Examples\n    --------\n    &gt;&gt;&gt; obs = Observable.from_interval(1.0)\n    &gt;&gt;&gt; await obs.take(3).to_list()\n    [0, 1, 2]\n    \"\"\"\n\n    async def emit_values(subscriber: Subscriber[int]) -&gt; None:\n        counter = 0\n        ack = Acknowledgement.ok\n        while ack == Acknowledgement.ok:\n            ack = await subscriber.on_next(counter)\n            counter += 1\n            await anyio.sleep(seconds)\n\n    return create_observable(emit_values)\n</code></pre>"},{"location":"2_observable_methods/#grugstream.core.Observable.from_iterable","title":"<code>from_iterable(iterable)</code>  <code>staticmethod</code>","text":"<p>Create an Observable from an iterable data source.</p> <p>Parameters:</p> Name Type Description Default <code>iterable</code> <code>Iterable</code> <p>The iterable source to convert to an Observable</p> required <p>Returns:</p> Type Description <code>Observable</code> <p>An Observable emitting the values from the iterable</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; obs = Observable.from_iterable([1, 2, 3])\n&gt;&gt;&gt; await obs.to_list()\n[1, 2, 3]\n</code></pre> Source code in <code>grugstream/core.py</code> <pre><code>@staticmethod\ndef from_iterable(iterable: Iterable[A]) -&gt; \"Observable[A]\":\n    \"\"\"Create an Observable from an iterable data source.\n\n    Parameters\n    ----------\n    iterable : Iterable\n        The iterable source to convert to an Observable\n\n    Returns\n    -------\n    Observable\n        An Observable emitting the values from the iterable\n\n    Examples\n    --------\n    &gt;&gt;&gt; obs = Observable.from_iterable([1, 2, 3])\n    &gt;&gt;&gt; await obs.to_list()\n    [1, 2, 3]\n    \"\"\"\n\n    class IterableObservable(Observable[B]):\n        async def subscribe(self, subscriber: Subscriber[A]) -&gt; None:\n            ack = Acknowledgement.ok\n            for item in iterable:\n                if ack != Acknowledgement.ok:  # If not OK, then stop.\n                    break\n                ack = await subscriber.on_next(item)\n            await subscriber.on_completed()\n\n    return IterableObservable()\n</code></pre>"},{"location":"2_observable_methods/#grugstream.core.Observable.from_iterable_thunk","title":"<code>from_iterable_thunk(thunk)</code>  <code>staticmethod</code>","text":"<p>Create an Observable from a thunk that returns an iterable. This is useful if you want to re-evaluate the iterable each time. For example, generators can only be iterated once, so you can use this to re-evaluate the generator each time.</p> <p>Parameters:</p> Name Type Description Default <code>thunk</code> <code>Callable</code> <p>The iterable source to convert to an Observable</p> required <p>Returns:</p> Type Description <code>Observable</code> <p>An Observable emitting the values from the iterable</p> <p>Examples:</p> <p>def gen():     for i in range(3):         yield i</p> <pre><code>&gt;&gt;&gt; obs = Observable.from_iterable_thunk(lambda: [1, 2, 3])\n&gt;&gt;&gt; await obs.to_list()\n[1, 2, 3]\n&gt;&gt;&gt; await obs.to_list() # can be called multiple times, each time it will re-evaluate the thunk\n[1, 2, 3]\n</code></pre> Source code in <code>grugstream/core.py</code> <pre><code>@staticmethod\ndef from_iterable_thunk(thunk: Callable[[], Iterable[A]]) -&gt; \"Observable[A]\":\n    \"\"\"Create an Observable from a thunk that returns an iterable.\n    This is useful if you want to re-evaluate the iterable each time.\n    For example, generators can only be iterated once, so you can use this to\n    re-evaluate the generator each time.\n\n    Parameters\n    ----------\n    thunk : Callable\n        The iterable source to convert to an Observable\n\n    Returns\n    -------\n    Observable\n        An Observable emitting the values from the iterable\n\n    Examples\n    --------\n\n    def gen():\n        for i in range(3):\n            yield i\n\n    &gt;&gt;&gt; obs = Observable.from_iterable_thunk(lambda: [1, 2, 3])\n    &gt;&gt;&gt; await obs.to_list()\n    [1, 2, 3]\n    &gt;&gt;&gt; await obs.to_list() # can be called multiple times, each time it will re-evaluate the thunk\n    [1, 2, 3]\n    \"\"\"\n\n    class IterableObservable(Observable[B]):\n        async def subscribe(self, subscriber: Subscriber[A]) -&gt; None:\n            iterable_ = thunk()\n            ack = Acknowledgement.ok\n            for item in iterable_:\n                if ack != Acknowledgement.ok:  # If not OK, then stop.\n                    break\n                ack = await subscriber.on_next(item)\n            await subscriber.on_completed()\n\n    return IterableObservable()\n</code></pre>"},{"location":"2_observable_methods/#grugstream.core.Observable.from_many_observables","title":"<code>from_many_observables(*observables)</code>  <code>staticmethod</code>","text":"<p>Create an Observable from multiple Observables. Note that this will try to emit values from the multiple Observables concurrently.</p> <p>Returns:</p> Type Description <code>Observable</code> <p>Observable emitting all values from nested Observables.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; obs1 = Observable.from_iterable([1, 2])\n&gt;&gt;&gt; obs2 = Observable.from_iterable([3, 4])\n&gt;&gt;&gt; await Observable.from_many_observables(obs1, obs2).to_list()\n[1, 3, 2, 4]\n</code></pre> Source code in <code>grugstream/core.py</code> <pre><code>@staticmethod\ndef from_many_observables(*observables: Observable[A_co]) -&gt; \"Observable[A_co]\":\n    \"\"\"\n    Create an Observable from multiple Observables.\n    Note that this will try to emit values from the multiple Observables\n    concurrently.\n\n\n    Returns\n    -------\n    Observable\n        Observable emitting all values from nested Observables.\n\n    Examples\n    --------\n    &gt;&gt;&gt; obs1 = Observable.from_iterable([1, 2])\n    &gt;&gt;&gt; obs2 = Observable.from_iterable([3, 4])\n    &gt;&gt;&gt; await Observable.from_many_observables(obs1, obs2).to_list()\n    [1, 3, 2, 4]\n    \"\"\"\n    return Observable.from_iterable(observables).flatten_observable()\n</code></pre>"},{"location":"2_observable_methods/#grugstream.core.Observable.from_one","title":"<code>from_one(value)</code>","text":"<p>Create an Observable that emits a single value.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>A</code> <p>The value to emit.</p> required <p>Returns:</p> Type Description <code>Observable</code> <p>An Observable that emits the given value.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; obs = Observable.from_one(10)\n&gt;&gt;&gt; await obs.to_list()\n[10]\n</code></pre> Source code in <code>grugstream/core.py</code> <pre><code>def from_one(self, value: A) -&gt; \"Observable[A]\":\n    \"\"\"Create an Observable that emits a single value.\n\n    Parameters\n    ----------\n    value :\n        The value to emit.\n\n    Returns\n    -------\n    Observable\n        An Observable that emits the given value.\n\n    Examples\n    --------\n    &gt;&gt;&gt; obs = Observable.from_one(10)\n    &gt;&gt;&gt; await obs.to_list()\n    [10]\n\n    \"\"\"\n    return self.from_iterable([value])\n</code></pre>"},{"location":"2_observable_methods/#grugstream.core.Observable.from_one_option","title":"<code>from_one_option(value)</code>","text":"<p>Create an Observable emitting value if not None.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Any</code> <p>The value to emit. If None, emits nothing.</p> required <p>Returns:</p> Type Description <code>Observable</code> <p>Observable emitting value if not None, otherwise empty.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; obs = Observable.from_one_option(10)\n&gt;&gt;&gt; await obs.to_list()\n[10]\n</code></pre> <pre><code>&gt;&gt;&gt; obs = Observable.from_one_option(None)\n&gt;&gt;&gt; await obs.to_list()\n[]\n</code></pre> Source code in <code>grugstream/core.py</code> <pre><code>def from_one_option(self, value: A | None) -&gt; \"Observable[A]\":\n    \"\"\"Create an Observable emitting value if not None.\n\n    Parameters\n    ----------\n    value : Any\n        The value to emit. If None, emits nothing.\n\n    Returns\n    -------\n    Observable\n        Observable emitting value if not None, otherwise empty.\n\n    Examples\n    --------\n    &gt;&gt;&gt; obs = Observable.from_one_option(10)\n    &gt;&gt;&gt; await obs.to_list()\n    [10]\n\n    &gt;&gt;&gt; obs = Observable.from_one_option(None)\n    &gt;&gt;&gt; await obs.to_list()\n    []\n    \"\"\"\n    return self.from_iterable([value]) if value is not None else self.from_iterable([])\n</code></pre>"},{"location":"2_observable_methods/#grugstream.core.Observable.map","title":"<code>map(func)</code>","text":"<p>Map values emitted by this Observable.</p> <p>Applies a mapping function to each item emitted by the source.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable</code> <p>The mapping function to apply to each item.</p> required <p>Returns:</p> Type Description <code>Observable</code> <p>An Observable with the mapped values.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; obs = Observable.from_iterable([1, 2, 3])\n&gt;&gt;&gt; mapped = await obs.map(lambda x: x * 2).to_list()\n&gt;&gt;&gt; mapped\n[2, 4, 6]\n</code></pre> Source code in <code>grugstream/core.py</code> <pre><code>def map(self: Observable[A], func: Callable[[A], B_co]) -&gt; \"Observable[B_co]\":\n    \"\"\"Map values emitted by this Observable.\n\n    Applies a mapping function to each item emitted by the source.\n\n    Parameters\n    ----------\n    func : Callable\n        The mapping function to apply to each item.\n\n    Returns\n    -------\n    Observable\n        An Observable with the mapped values.\n\n    Examples\n    --------\n    &gt;&gt;&gt; obs = Observable.from_iterable([1, 2, 3])\n    &gt;&gt;&gt; mapped = await obs.map(lambda x: x * 2).to_list()\n    &gt;&gt;&gt; mapped\n    [2, 4, 6]\n    \"\"\"\n    source = self\n\n    async def subscribe(subscriber: Subscriber[B_co]) -&gt; None:\n        async def on_next(value: A) -&gt; Acknowledgement:\n            try:\n                transformed_value = func(value)\n                return await subscriber.on_next(transformed_value)\n            except Exception as e:\n                await subscriber.on_error(e)\n                return Acknowledgement.stop\n\n        map_subscriber = create_subscriber(\n            on_next=on_next, on_error=subscriber.on_error, on_completed=subscriber.on_completed\n        )\n\n        await source.subscribe(map_subscriber)\n\n    return create_observable(subscribe)\n</code></pre>"},{"location":"2_observable_methods/#grugstream.core.Observable.map_2","title":"<code>map_2(func)</code>","text":"<p>Map an Observable of pairs using a two-arg function.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable</code> <p>The mapping function taking two arguments.</p> required <p>Returns:</p> Type Description <code>Observable</code> <p>An Observable with the mapped values.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; obs = Observable.from_iterable([(1, 'a'), (2, 'b')])\n&gt;&gt;&gt; mapped = obs.map_2(lambda x, y: (x, y.upper()))\n&gt;&gt;&gt; await mapped.to_list()\n[(1, 'A'), (2, 'B')]\n</code></pre> Source code in <code>grugstream/core.py</code> <pre><code>def map_2(self: \"Observable[tuple[A, B]]\", func: Callable[[A, B], C]) -&gt; \"Observable[C]\":\n    \"\"\"Map an Observable of pairs using a two-arg function.\n\n    Parameters\n    ----------\n    func : Callable\n        The mapping function taking two arguments.\n\n    Returns\n    -------\n    Observable\n        An Observable with the mapped values.\n\n    Examples\n    --------\n    &gt;&gt;&gt; obs = Observable.from_iterable([(1, 'a'), (2, 'b')])\n    &gt;&gt;&gt; mapped = obs.map_2(lambda x, y: (x, y.upper()))\n    &gt;&gt;&gt; await mapped.to_list()\n    [(1, 'A'), (2, 'B')]\n    \"\"\"\n    return self.map(lambda x: func(x[0], x[1]))\n</code></pre>"},{"location":"2_observable_methods/#grugstream.core.Observable.map_2_async","title":"<code>map_2_async(func)</code>","text":"<p>Map pairs asynchronously using func.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable</code> <p>Async function taking two arguments to apply.</p> required <p>Returns:</p> Type Description <code>Observable</code> <p>An Observable with asynchronously mapped values.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; async def concat(x, y):\n&gt;&gt;&gt;     await asyncio.sleep(1)\n&gt;&gt;&gt;     return f'{x}.{y}'\n&gt;&gt;&gt; obs = Observable.from_iterable([('a', 1), ('b', 2)])\n&gt;&gt;&gt; mapped = obs.map_2_async(concat)\n&gt;&gt;&gt; await mapped.to_list()\n['a.1', 'b.2']\n</code></pre> Source code in <code>grugstream/core.py</code> <pre><code>def map_2_async(self: \"Observable[tuple[A, B]]\", func: Callable[[A, B], Awaitable[C]]) -&gt; \"Observable[C]\":\n    \"\"\"Map pairs asynchronously using func.\n\n    Parameters\n    ----------\n    func : Callable\n        Async function taking two arguments to apply.\n\n    Returns\n    -------\n    Observable\n        An Observable with asynchronously mapped values.\n\n    Examples\n    --------\n    &gt;&gt;&gt; async def concat(x, y):\n    &gt;&gt;&gt;     await asyncio.sleep(1)\n    &gt;&gt;&gt;     return f'{x}.{y}'\n    &gt;&gt;&gt; obs = Observable.from_iterable([('a', 1), ('b', 2)])\n    &gt;&gt;&gt; mapped = obs.map_2_async(concat)\n    &gt;&gt;&gt; await mapped.to_list()\n    ['a.1', 'b.2']\n    \"\"\"\n    return self.map_async(lambda x: func(x[0], x[1]))\n</code></pre>"},{"location":"2_observable_methods/#grugstream.core.Observable.map_async","title":"<code>map_async(func)</code>","text":"<p>Map values asynchronously using func.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable</code> <p>Async function to apply to each value.</p> required <p>Returns:</p> Type Description <code>Observable</code> <p>An Observable with the asynchronously mapped values.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; async def double(x):\n&gt;&gt;&gt;     await asyncio.sleep(1)\n&gt;&gt;&gt;     return x * 2\n&gt;&gt;&gt; obs = Observable.from_iterable([1, 2, 3])\n&gt;&gt;&gt; mapped = obs.map_async(double)\n&gt;&gt;&gt; await mapped.to_list()\n[2, 4, 6]\n</code></pre> Source code in <code>grugstream/core.py</code> <pre><code>def map_async(self: Observable[A], func: Callable[[A], Awaitable[B_co]]) -&gt; 'Observable[B_co]':\n    \"\"\"Map values asynchronously using func.\n\n    Parameters\n    ----------\n    func : Callable\n        Async function to apply to each value.\n\n    Returns\n    -------\n    Observable\n        An Observable with the asynchronously mapped values.\n\n    Examples\n    --------\n    &gt;&gt;&gt; async def double(x):\n    &gt;&gt;&gt;     await asyncio.sleep(1)\n    &gt;&gt;&gt;     return x * 2\n    &gt;&gt;&gt; obs = Observable.from_iterable([1, 2, 3])\n    &gt;&gt;&gt; mapped = obs.map_async(double)\n    &gt;&gt;&gt; await mapped.to_list()\n    [2, 4, 6]\n    \"\"\"\n    source = self\n\n    async def subscribe_async(subscriber: Subscriber[B_co]) -&gt; None:\n        async def on_next(value: A) -&gt; Acknowledgement:\n            try:\n                transformed_value = await func(value)\n            except Exception as e:\n                await subscriber.on_error(e)\n                return Acknowledgement.stop\n\n            return await subscriber.on_next(transformed_value)\n\n        map_subscriber = create_subscriber(\n            on_next=on_next, on_error=subscriber.on_error, on_completed=subscriber.on_completed\n        )\n\n        await source.subscribe(map_subscriber)\n\n    return create_observable(subscribe_async)\n</code></pre>"},{"location":"2_observable_methods/#grugstream.core.Observable.map_async_par","title":"<code>map_async_par(func, max_buffer_size=100, max_par=50)</code>","text":"<p>Map values asynchronously in parallel using func.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable</code> <p>Async function to apply to each value.</p> required <code>max_buffer_size</code> <code>int</code> <p>Max size of buffer for pending values. If None is passed, an infinite buffer is created.</p> <code>100</code> <code>max_par</code> <code>int</code> <p>Max number of concurrent mappings.</p> <code>50</code> <p>Returns:</p> Type Description <code>Observable</code> <p>An Observable with the asynchronously mapped values.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; async def slow_double(x):\n&gt;&gt;&gt;     await asyncio.sleep(1)\n&gt;&gt;&gt;     return x * 2\n&gt;&gt;&gt; source = Observable.interval(0.1).take(10)\n&gt;&gt;&gt; mapped = source.map_async_par(slow_double, max_par=3)\n&gt;&gt;&gt; await mapped.to_list() # runs ~3x faster due to parallel mapping\n[0, 2, 4, 6, 8, 10, 12, 14, 16, 18]\n</code></pre> Source code in <code>grugstream/core.py</code> <pre><code>def map_async_par(\n    self: Observable[A], func: Callable[[A], Awaitable[B]], max_buffer_size: int | None = 100, max_par: int = 50\n) -&gt; 'Observable[B]':\n    \"\"\"Map values asynchronously in parallel using func.\n\n    Parameters\n    ----------\n    func : Callable\n        Async function to apply to each value.\n    max_buffer_size : int, optional\n        Max size of buffer for pending values. If None is passed, an infinite buffer is created.\n    max_par : int, optional\n        Max number of concurrent mappings.\n\n    Returns\n    -------\n    Observable\n        An Observable with the asynchronously mapped values.\n\n    Examples\n    --------\n    &gt;&gt;&gt; async def slow_double(x):\n    &gt;&gt;&gt;     await asyncio.sleep(1)\n    &gt;&gt;&gt;     return x * 2\n    &gt;&gt;&gt; source = Observable.interval(0.1).take(10)\n    &gt;&gt;&gt; mapped = source.map_async_par(slow_double, max_par=3)\n    &gt;&gt;&gt; await mapped.to_list() # runs ~3x faster due to parallel mapping\n    [0, 2, 4, 6, 8, 10, 12, 14, 16, 18]\n    \"\"\"\n    source = self\n\n    async def process_with_function(\n        subscriber: Subscriber[B], tg: TaskGroup, receive_stream: MemoryObjectReceiveStream[B]\n    ) -&gt; None:\n        semaphore = anyio.Semaphore(max_par)\n\n        async def process_item(item: A) -&gt; None:\n            async with semaphore:\n                try:\n                    result = await func(item)\n                except Exception as e:\n                    await subscriber.on_error(e)\n                    tg.cancel_scope.cancel()\n                ack = await subscriber.on_next(result)  # type: ignore\n            if ack == Acknowledgement.stop:\n                tg.cancel_scope.cancel()\n\n        async for item in receive_stream:\n            tg.start_soon(process_item, item) # type: ignore\n\n    async def subscribe_async(subscriber: Subscriber[B]) -&gt; None:\n        send_stream, receive_stream = create_memory_object_stream(\n            max_buffer_size=max_buffer_size if max_buffer_size is not None else math.inf\n        )\n        try:\n\n            async def on_next(value: A) -&gt; Acknowledgement:\n                await send_stream.send(value)\n                return Acknowledgement.ok\n\n            async def on_completed() -&gt; None:\n                await send_stream.aclose()\n\n            send_to_stream_subscriber = create_subscriber(\n                on_next=on_next, on_completed=on_completed, on_error=subscriber.on_error\n            )\n\n            async with create_task_group() as tg:\n                tg.start_soon(source.subscribe, send_to_stream_subscriber)\n                tg.start_soon(process_with_function, subscriber, tg, receive_stream)\n            await subscriber.on_completed()\n\n        except Exception as e:\n            await subscriber.on_error(e)\n        finally:\n            await send_stream.aclose()\n\n    return create_observable(subscribe_async)\n</code></pre>"},{"location":"2_observable_methods/#grugstream.core.Observable.map_blocking_par","title":"<code>map_blocking_par(func, max_par=50, max_buffer_size=50)</code>","text":"<p>Map values blocking functions in parallel using func. Only use this for IO bound functions - e.g. old code that aren't async functions</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable</code> <p>blocking function to apply to each value.</p> required <code>max_par</code> <code>int</code> <p>Max number of concurrent mappings.</p> <code>50</code> <code>max_buffer_size</code> <code>int</code> <p>Max size of buffer for pending values.</p> <code>50</code> <p>Returns:</p> Type Description <code>Observable</code> <p>An Observable with the mapped values.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; def slow_double(x):\n&gt;&gt;&gt;     time.sleep(1)\n&gt;&gt;&gt;     return x * 2\n&gt;&gt;&gt; mapped = Observable.map_blocking_par(slow_double).take(10)\n&gt;&gt;&gt; await mapped.to_list() # runs ~3x faster due to parallel mapping\n[0, 2, 4, 6, 8, 10, 12, 14, 16, 18]\n</code></pre> Source code in <code>grugstream/core.py</code> <pre><code>def map_blocking_par(\n    self: Observable[A], func: Callable[[A], B_co], max_par: int | CapacityLimiter = 50, max_buffer_size: int = 50\n) -&gt; 'Observable[B_co]':\n    \"\"\"Map values blocking functions in parallel using func.\n    Only use this for IO bound functions - e.g. old code that aren't async functions\n\n    Parameters\n    ----------\n    func : Callable\n        blocking function to apply to each value.\n    max_par : int, optional\n        Max number of concurrent mappings.\n    max_buffer_size : int, optional\n        Max size of buffer for pending values.\n\n    Returns\n    -------\n    Observable\n        An Observable with the mapped values.\n\n    Examples\n    --------\n    &gt;&gt;&gt; def slow_double(x):\n    &gt;&gt;&gt;     time.sleep(1)\n    &gt;&gt;&gt;     return x * 2\n    &gt;&gt;&gt; mapped = Observable.map_blocking_par(slow_double).take(10)\n    &gt;&gt;&gt; await mapped.to_list() # runs ~3x faster due to parallel mapping\n    [0, 2, 4, 6, 8, 10, 12, 14, 16, 18]\n    \"\"\"\n    limiter: CapacityLimiter = max_par if isinstance(max_par, CapacityLimiter) else CapacityLimiter(max_par)\n    from anyio import to_thread\n\n    async def wrapped_func(value: A) -&gt; B_co:\n        return await to_thread.run_sync(func, value, limiter=limiter)\n\n    return self.map_async_par(wrapped_func, max_par=int(limiter.total_tokens), max_buffer_size=max_buffer_size)\n</code></pre>"},{"location":"2_observable_methods/#grugstream.core.Observable.map_enumerated","title":"<code>map_enumerated(func)</code>","text":"<p>Map enumerated values from the Observable.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable</code> <p>The mapping function to apply, taking the index and value.</p> required <p>Returns:</p> Type Description <code>Observable</code> <p>An Observable with the mapped enumerated values.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; obs = Observable.from_iterable(['a', 'b', 'c'])\n&gt;&gt;&gt; mapped = obs.map_enumerated(lambda i, x: str(i) + x)\n&gt;&gt;&gt; await mapped.to_list()\n['0a', '1b', '2c']\n</code></pre> Source code in <code>grugstream/core.py</code> <pre><code>def map_enumerated(self, func: Callable[[int, A_co], B_co]) -&gt; \"Observable[B_co]\":\n    \"\"\"Map enumerated values from the Observable.\n\n    Parameters\n    ----------\n    func : Callable\n        The mapping function to apply, taking the index and value.\n\n    Returns\n    -------\n    Observable\n        An Observable with the mapped enumerated values.\n\n    Examples\n    --------\n    &gt;&gt;&gt; obs = Observable.from_iterable(['a', 'b', 'c'])\n    &gt;&gt;&gt; mapped = obs.map_enumerated(lambda i, x: str(i) + x)\n    &gt;&gt;&gt; await mapped.to_list()\n    ['0a', '1b', '2c']\n    \"\"\"\n    return self.enumerated().map_2(func)\n</code></pre>"},{"location":"2_observable_methods/#grugstream.core.Observable.merge_with","title":"<code>merge_with(*others)</code>","text":"<p>Merge this Observable with other Observables.</p> <p>Parameters:</p> Name Type Description Default <code>others</code> <code>Observable</code> <p>Other Observables to merge with.</p> <code>()</code> <p>Returns:</p> Type Description <code>Observable</code> <p>Observable emitting values from this and others Observables. Note that this will not preserve order between Observables.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; obs1 = Observable.from_iterable([1, 2])\n&gt;&gt;&gt; obs2 = Observable.from_iterable([3, 4])\n&gt;&gt;&gt; merged = obs1.merge_with(obs2)\n&gt;&gt;&gt; await merged.to_list()\n[1, 3, 4, 2]\n</code></pre> Source code in <code>grugstream/core.py</code> <pre><code>def merge_with(self: 'Observable[A_co]', *others: 'Observable[A_co]') -&gt; 'Observable[A_co]':\n    \"\"\"Merge this Observable with other Observables.\n\n    Parameters\n    ----------\n    others : Observable\n        Other Observables to merge with.\n    Returns\n    -------\n    Observable\n        Observable emitting values from this and others Observables. Note that this\n        will not preserve order between Observables.\n\n    Examples\n    --------\n    &gt;&gt;&gt; obs1 = Observable.from_iterable([1, 2])\n    &gt;&gt;&gt; obs2 = Observable.from_iterable([3, 4])\n    &gt;&gt;&gt; merged = obs1.merge_with(obs2)\n    &gt;&gt;&gt; await merged.to_list()\n    [1, 3, 4, 2]\n    \"\"\"\n    new = self.from_iterable([self, *others])\n    return new.flatten_observable()\n</code></pre>"},{"location":"2_observable_methods/#grugstream.core.Observable.on_error_restart","title":"<code>on_error_restart(max_restarts=1000, exceptions=(Exception), log_restarting_func=lambda restart_count, exception: print(f'Encountered {exception}, restarting with try {restart_count}'), log_unhandled_func=lambda restart_count, exception: print(f'Encountered unhandled {exception}, total restarts so far: {restart_count}'))</code>","text":"<p>Restarts the observable if the exceptions are encountered</p> Source code in <code>grugstream/core.py</code> <pre><code>def on_error_restart(\n    self: Observable[A_co],\n    max_restarts: int | None = 1000,\n    exceptions: tuple[type[Exception]] = (Exception,),\n    log_restarting_func: Callable[[int, Exception], None] | None = lambda restart_count, exception: print(\n        f\"Encountered {exception}, restarting with try {restart_count}\"\n    ),\n    log_unhandled_func: Callable[[int, Exception], None] | None = lambda restart_count, exception: print(\n        f\"Encountered unhandled {exception}, total restarts so far: {restart_count}\"\n    ),\n) -&gt; \"Observable[A_co]\":\n    \"\"\"Restarts the observable if the exceptions are encountered\"\"\"\n    source: Observable[A_co] = self\n    count = 0\n    if max_restarts is not None:\n        assert max_restarts &gt; 0, \"max_restarts must be more than 0\"\n    max_restarts_num = max_restarts if max_restarts is not None else math.inf\n\n    async def subscribe(subscriber: Subscriber[A_co]) -&gt; None:\n        class RestartSubscriber(Subscriber[B]):\n            def __init__(self) -&gt; None:\n                self.__threshold_reached: bool = False\n\n            async def on_error(self, error: Exception) -&gt; None:\n                if isinstance(error, exceptions):\n                    nonlocal count\n                    count += 1\n                    if count &lt;= max_restarts_num:\n                        if log_restarting_func:\n                            log_restarting_func(count, error)\n                        # restart\n                        # TODO: Trampoline to avoid infinite recursive blowup?\n                        restarted_subscriber = RestartSubscriber()\n                        await source.subscribe(restarted_subscriber)\n                        return None\n                if log_unhandled_func:\n                    log_unhandled_func(count, error)\n                # Raise if max restart reached or not caught\n                self.__threshold_reached = True\n                raise error\n\n            async def on_next(self, value: B) -&gt; Acknowledgement:\n                if self.__threshold_reached:\n                    return Acknowledgement.stop\n                else:\n                    return await subscriber.on_next(value)  # type: ignore\n\n        subscriber_with_on_error = RestartSubscriber()\n\n        await source.subscribe(subscriber_with_on_error)\n\n    return create_observable(subscribe)\n</code></pre>"},{"location":"2_observable_methods/#grugstream.core.Observable.print","title":"<code>print(prefix='', printer=print)</code>","text":"<p>Print values from the Observable using print().</p> <p>Prints each value emitted by the Observable after prepending <code>prefix</code>.</p> <p>Parameters:</p> Name Type Description Default <code>prefix</code> <code>str</code> <p>String to prepend to printed values.</p> <code>\"\"</code> <code>printer</code> <code>Callable</code> <p>Function to use for printing.</p> <code>print</code> <p>Returns:</p> Type Description <code>Observable</code> <p>Output Observable with unchanged values.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; obs = Observable.from_iterable([1, 2, 3])\n&gt;&gt;&gt; obs.print(\"Item: \").to_list()\nItem: 1\nItem: 2\nItem: 3\n[1, 2, 3]\n</code></pre> Source code in <code>grugstream/core.py</code> <pre><code>def print(\n    self: \"Observable[A_co]\", prefix: str = \"\", printer: Callable[[A_co], None] = print\n) -&gt; \"Observable[A_co]\":\n    \"\"\"Print values from the Observable using print().\n\n    Prints each value emitted by the Observable after prepending\n    `prefix`.\n\n    Parameters\n    ----------\n    prefix : str, default \"\"\n        String to prepend to printed values.\n    printer : Callable, default print\n        Function to use for printing.\n\n    Returns\n    -------\n    Observable\n        Output Observable with unchanged values.\n\n    Examples\n    --------\n    &gt;&gt;&gt; obs = Observable.from_iterable([1, 2, 3])\n    &gt;&gt;&gt; obs.print(\"Item: \").to_list()\n    Item: 1\n    Item: 2\n    Item: 3\n    [1, 2, 3]\n    \"\"\"\n    return self.for_each(lambda x: printer(f\"{prefix}{x}\"))  # type: ignore\n</code></pre>"},{"location":"2_observable_methods/#grugstream.core.Observable.product","title":"<code>product(other)</code>","text":"<p>Combine values from this Observable with another iterable.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Iterable</code> <p>The other iterable to combine with.</p> required <p>Returns:</p> Type Description <code>Observable</code> <p>An Observable of tuples of values from this Observable and the other.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; obs = Observable.from_iterable([1, 2])\n&gt;&gt;&gt; other = ['a', 'b']\n&gt;&gt;&gt; product = obs.product(other)\n&gt;&gt;&gt; await product.to_list()\n[(1, 'a'), (1, 'b'), (2, 'a'), (2, 'b')]\n</code></pre> Source code in <code>grugstream/core.py</code> <pre><code>def product(self: Observable[A], other: Iterable[B]) -&gt; \"Observable[tuple[A, B]]\":\n    \"\"\"Combine values from this Observable with another iterable.\n\n    Parameters\n    ----------\n    other : Iterable\n        The other iterable to combine with.\n\n    Returns\n    -------\n    Observable\n        An Observable of tuples of values from this Observable and the other.\n\n    Examples\n    --------\n    &gt;&gt;&gt; obs = Observable.from_iterable([1, 2])\n    &gt;&gt;&gt; other = ['a', 'b']\n    &gt;&gt;&gt; product = obs.product(other)\n    &gt;&gt;&gt; await product.to_list()\n    [(1, 'a'), (1, 'b'), (2, 'a'), (2, 'b')]\n    \"\"\"\n    return self.map(lambda x: product([x], other)).flatten_iterable()\n</code></pre>"},{"location":"2_observable_methods/#grugstream.core.Observable.reduce","title":"<code>reduce(func, initial)</code>  <code>async</code>","text":"<p>Reduce the Observable using <code>func</code>, starting with <code>initial</code>.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[[A, A], A]</code> <p>Function to apply to accumulate values.</p> required <code>initial</code> <code>A</code> <p>Initial value to start reduction from.</p> required <p>Returns:</p> Type Description <code>A</code> <p>Final accumulated reduction value.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; obs = Observable.from_iterable([1, 2, 3])\n&gt;&gt;&gt; await obs.reduce(lambda acc, x: acc + x, 0)\n6\n</code></pre> Source code in <code>grugstream/core.py</code> <pre><code>async def reduce(self, func: Callable[[A, A], A], initial: A) -&gt; A:\n    \"\"\"Reduce the Observable using `func`, starting with `initial`.\n\n    Parameters\n    ----------\n    func : Callable[[A, A], A]\n        Function to apply to accumulate values.\n    initial : A\n        Initial value to start reduction from.\n\n    Returns\n    -------\n    A\n        Final accumulated reduction value.\n\n    Examples\n    --------\n    &gt;&gt;&gt; obs = Observable.from_iterable([1, 2, 3])\n    &gt;&gt;&gt; await obs.reduce(lambda acc, x: acc + x, 0)\n    6\n    \"\"\"\n    result = initial\n\n    async def on_next(value: A) -&gt; Acknowledgement:\n        nonlocal result\n        result = func(result, value)\n        return Acknowledgement.ok\n\n    reduce_subscriber = create_subscriber(on_next=on_next, on_completed=None, on_error=None)\n\n    await self.subscribe(reduce_subscriber)\n\n    return result\n</code></pre>"},{"location":"2_observable_methods/#grugstream.core.Observable.run_to_completion","title":"<code>run_to_completion()</code>  <code>async</code>","text":"<p>Run the Observable and count emitted values.</p> <p>Runs the Observable until completion, counting the number of final values emitted.</p> <p>Returns:</p> Type Description <code>int</code> <p>Number of values emitted before completion.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; obs = Observable.from_iterable([1, 2, 3]).take(2)\n&gt;&gt;&gt; await obs.run_to_completion()\n2\n</code></pre> Source code in <code>grugstream/core.py</code> <pre><code>async def run_to_completion(self) -&gt; int:\n    \"\"\"Run the Observable and count emitted values.\n\n    Runs the Observable until completion, counting the\n    number of final values emitted.\n\n    Returns\n    -------\n    int\n        Number of values emitted before completion.\n\n    Examples\n    --------\n    &gt;&gt;&gt; obs = Observable.from_iterable([1, 2, 3]).take(2)\n    &gt;&gt;&gt; await obs.run_to_completion()\n    2\n    \"\"\"\n    count = 0\n\n    async def on_next(value: Any) -&gt; Acknowledgement:\n        nonlocal count\n        count = count + 1\n        return Acknowledgement.ok\n\n    subscriber = create_subscriber(on_next=on_next, on_completed=None, on_error=None)\n\n    await self.subscribe(subscriber)\n\n    return count\n</code></pre>"},{"location":"2_observable_methods/#grugstream.core.Observable.run_until_timeout","title":"<code>run_until_timeout(seconds)</code>  <code>async</code>","text":"<p>Run the Observable until a timeout occurs.</p> <p>Runs the Observable until <code>seconds</code> elapse, counting the number of values emitted in that time.</p> <p>Parameters:</p> Name Type Description Default <code>seconds</code> <code>float</code> <p>Number of seconds to run for.</p> required <p>Returns:</p> Type Description <code>int</code> <p>Count of values emitted before timeout.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; obs = Observable.from_interval(0.1)\n&gt;&gt;&gt; await obs.run_until_timeout(0.3)\n# Emits ~3 values in 0.3 seconds\n</code></pre> Source code in <code>grugstream/core.py</code> <pre><code>async def run_until_timeout(self, seconds: float) -&gt; int:\n    \"\"\"Run the Observable until a timeout occurs.\n\n    Runs the Observable until `seconds` elapse, counting the\n    number of values emitted in that time.\n\n    Parameters\n    ----------\n    seconds : float\n        Number of seconds to run for.\n\n    Returns\n    -------\n    int\n        Count of values emitted before timeout.\n\n    Examples\n    --------\n    &gt;&gt;&gt; obs = Observable.from_interval(0.1)\n    &gt;&gt;&gt; await obs.run_until_timeout(0.3)\n    # Emits ~3 values in 0.3 seconds\n    \"\"\"\n    count = 0\n\n    class AnonymousSubscriber(Subscriber[A]):\n        async def on_next(self, value: A) -&gt; Acknowledgement:\n            nonlocal count\n            count = count + 1\n            return Acknowledgement.ok\n\n        async def on_error(self, error: Exception) -&gt; None:\n            task_group.cancel_scope.cancel()\n            raise error\n\n        async def on_completed(self) -&gt; None:\n            task_group.cancel_scope.cancel()\n\n    subscriber = AnonymousSubscriber()\n\n    async def timeout_task():\n        await anyio.sleep(seconds)\n        task_group.cancel_scope.cancel()\n\n    async with create_task_group() as tg:\n        task_group = tg  # Set the task_group so we can cancel it in other methods\n        tg.start_soon(self.subscribe, subscriber)\n        tg.start_soon(timeout_task)\n\n    return count\n</code></pre>"},{"location":"2_observable_methods/#grugstream.core.Observable.subscribe","title":"<code>subscribe(subscriber)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Subscribe async subscriber.</p> Source code in <code>grugstream/core.py</code> <pre><code>@abstractmethod\nasync def subscribe(self, subscriber: \"Subscriber[A_co]\") -&gt; None:\n    \"\"\"Subscribe async subscriber.\"\"\"\n    pass\n</code></pre>"},{"location":"2_observable_methods/#grugstream.core.Observable.sum","title":"<code>sum()</code>  <code>async</code>","text":"<p>Sum all emitted values.</p> <p>Returns:</p> Type Description <code>int | float</code> <p>Sum of all emitted values.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; obs = Observable.from_iterable([1, 2, 3])\n&gt;&gt;&gt; await obs.sum()\n6\n</code></pre> Source code in <code>grugstream/core.py</code> <pre><code>async def sum(self: 'Observable[int | float]') -&gt; int | float:\n    \"\"\"Sum all emitted values.\n\n    Returns\n    -------\n    int | float\n        Sum of all emitted values.\n\n    Examples\n    --------\n    &gt;&gt;&gt; obs = Observable.from_iterable([1, 2, 3])\n    &gt;&gt;&gt; await obs.sum()\n    6\n    \"\"\"\n    return await self.reduce(lambda a, b: a + b, 0)\n</code></pre>"},{"location":"2_observable_methods/#grugstream.core.Observable.sum_option","title":"<code>sum_option()</code>  <code>async</code>","text":"<p>Sum values using +, return None if empty.</p> <p>Returns:</p> Type Description <code>Optional[CanAdd]</code> <p>Sum of values or None if empty.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; obs = Observable.from_iterable([1, 2, 3])\n&gt;&gt;&gt; await obs.sum_option()\n6\n&gt;&gt;&gt; empty = Observable.from_iterable([])\n&gt;&gt;&gt; await empty.sum_option()\nNone\n</code></pre> Source code in <code>grugstream/core.py</code> <pre><code>async def sum_option(self: \"Observable[CanAdd]\") -&gt; Optional[CanAdd]:\n    \"\"\"Sum values using +, return None if empty.\n\n    Returns\n    -------\n    Optional[CanAdd]\n        Sum of values or None if empty.\n\n    Examples\n    --------\n    &gt;&gt;&gt; obs = Observable.from_iterable([1, 2, 3])\n    &gt;&gt;&gt; await obs.sum_option()\n    6\n    &gt;&gt;&gt; empty = Observable.from_iterable([])\n    &gt;&gt;&gt; await empty.sum_option()\n    None\n    \"\"\"\n    result = None\n\n    async def on_next(value: CanAdd) -&gt; Acknowledgement:\n        nonlocal result\n        result = value if result is None else result + value\n        return Acknowledgement.ok\n\n    reduce_subscriber = create_subscriber(on_next=on_next, on_completed=None, on_error=None)\n\n    await self.subscribe(reduce_subscriber)\n\n    return result\n</code></pre>"},{"location":"2_observable_methods/#grugstream.core.Observable.sum_or_raise","title":"<code>sum_or_raise()</code>  <code>async</code>","text":"<p>Sum values using +, raise if empty.</p> <p>Raises:</p> Type Description <code>GrugSumError</code> <p>If the Observable is empty.</p> <p>Returns:</p> Type Description <code>CanAdd</code> <p>Sum of values.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; obs = Observable.from_iterable([1, 2, 3])\n&gt;&gt;&gt; await obs.sum_or_raise()\n6\n&gt;&gt;&gt; empty = Observable.from_iterable([])\n&gt;&gt;&gt; await empty.sum_or_raise()\n# raises GrugSumError\n</code></pre> Source code in <code>grugstream/core.py</code> <pre><code>async def sum_or_raise(self: \"Observable[CanAdd]\") -&gt; CanAdd:\n    \"\"\"Sum values using +, raise if empty.\n\n    Raises\n    ------\n    GrugSumError\n        If the Observable is empty.\n\n    Returns\n    -------\n    CanAdd\n        Sum of values.\n\n    Examples\n    --------\n    &gt;&gt;&gt; obs = Observable.from_iterable([1, 2, 3])\n    &gt;&gt;&gt; await obs.sum_or_raise()\n    6\n    &gt;&gt;&gt; empty = Observable.from_iterable([])\n    &gt;&gt;&gt; await empty.sum_or_raise()\n    # raises GrugSumError\n    \"\"\"\n    result = await self.sum_option()\n    if result is None:\n        raise GrugSumError(\"Cannot sum an empty observable\")\n    return result\n</code></pre>"},{"location":"2_observable_methods/#grugstream.core.Observable.take","title":"<code>take(n)</code>","text":"<p>Take the first n values from the Observable.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Number of values to take.</p> required <p>Returns:</p> Type Description <code>Observable</code> <p>Observable emitting the first n values.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; obs = Observable.from_iterable([1, 2, 3, 4, 5])\n&gt;&gt;&gt; taken = obs.take(3)\n&gt;&gt;&gt; await taken.to_list()\n[1, 2, 3]\n</code></pre> Source code in <code>grugstream/core.py</code> <pre><code>def take(self: Observable[A], n: int) -&gt; 'Observable[A]':\n    \"\"\"Take the first n values from the Observable.\n\n    Parameters\n    ----------\n    n : int\n        Number of values to take.\n\n    Returns\n    -------\n    Observable\n        Observable emitting the first n values.\n\n    Examples\n    --------\n    &gt;&gt;&gt; obs = Observable.from_iterable([1, 2, 3, 4, 5])\n    &gt;&gt;&gt; taken = obs.take(3)\n    &gt;&gt;&gt; await taken.to_list()\n    [1, 2, 3]\n    \"\"\"\n    source = self\n\n    async def subscribe_async(subscriber: Subscriber[A]) -&gt; None:\n        count = 0\n\n        async def on_next(value: A) -&gt; Acknowledgement:\n            nonlocal count\n            count += 1\n            if count &lt; n:\n                return await subscriber.on_next(value)\n            else:\n                # call on_completed when maximum count is reached\n                # Call on_next one last time\n                await subscriber.on_next(value)\n                # Call on_completed\n                await subscriber.on_completed()\n                return Acknowledgement.stop\n\n        take_subscriber = create_subscriber(\n            on_next=on_next, on_error=subscriber.on_error, on_completed=subscriber.on_completed\n        )\n\n        await source.subscribe(take_subscriber)\n\n    return create_observable(subscribe_async)\n</code></pre>"},{"location":"2_observable_methods/#grugstream.core.Observable.take_last","title":"<code>take_last(n)</code>","text":"<p>Take the last n values from the Observable.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Number of last values to take.</p> required <p>Returns:</p> Type Description <code>Observable</code> <p>Observable emitting the last n values.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; obs = Observable.from_iterable([1, 2, 3, 4, 5])\n&gt;&gt;&gt; taken = obs.take_last(2)\n&gt;&gt;&gt; await taken.to_list()\n[4, 5]\n</code></pre> Source code in <code>grugstream/core.py</code> <pre><code>def take_last(self: Observable[A], n: int) -&gt; 'Observable[A]':\n    \"\"\"Take the last n values from the Observable.\n\n    Parameters\n    ----------\n    n : int\n        Number of last values to take.\n\n    Returns\n    -------\n    Observable\n        Observable emitting the last n values.\n\n    Examples\n    --------\n    &gt;&gt;&gt; obs = Observable.from_iterable([1, 2, 3, 4, 5])\n    &gt;&gt;&gt; taken = obs.take_last(2)\n    &gt;&gt;&gt; await taken.to_list()\n    [4, 5]\n    \"\"\"\n    source = self\n    buffer = deque(maxlen=n)\n\n    async def subscribe_async(subscriber: Subscriber[A]) -&gt; None:\n        async def on_next(value: A) -&gt; Acknowledgement:\n            buffer.append(value)\n            return Acknowledgement.ok\n\n        async def on_completed() -&gt; None:\n            for item in buffer:\n                await subscriber.on_next(item)\n            await subscriber.on_completed()\n\n        take_last_subscriber = create_subscriber(\n            on_next=on_next,\n            on_completed=on_completed,\n            on_error=subscriber.on_error,\n        )\n\n        await source.subscribe(take_last_subscriber)\n\n    return create_observable(subscribe_async)\n</code></pre>"},{"location":"2_observable_methods/#grugstream.core.Observable.take_while_exclusive","title":"<code>take_while_exclusive(predicate)</code>","text":"<p>Take values until predicate is false.</p> <p>Stops before emitting the first value where <code>predicate</code> is false.</p> <p>Parameters:</p> Name Type Description Default <code>predicate</code> <code>Callable</code> <p>Function to test each value.</p> required <p>Returns:</p> Type Description <code>Observable</code> <p>Observable emitting values until predicate is false.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; obs = Observable.from_iterable([1, 2, 3, 4, 5])\n&gt;&gt;&gt; taken = obs.take_while_exclusive(lambda x: x &lt; 4)\n&gt;&gt;&gt; await taken.to_list()\n[1, 2, 3]\n</code></pre> Source code in <code>grugstream/core.py</code> <pre><code>def take_while_exclusive(self: Observable[A], predicate: Callable[[A], bool]) -&gt; 'Observable[A]':\n    \"\"\"Take values until predicate is false.\n\n    Stops **before** emitting the first value where `predicate` is false.\n\n    Parameters\n    ----------\n    predicate : Callable\n        Function to test each value.\n\n    Returns\n    -------\n    Observable\n        Observable emitting values until predicate is false.\n\n    Examples\n    --------\n    &gt;&gt;&gt; obs = Observable.from_iterable([1, 2, 3, 4, 5])\n    &gt;&gt;&gt; taken = obs.take_while_exclusive(lambda x: x &lt; 4)\n    &gt;&gt;&gt; await taken.to_list()\n    [1, 2, 3]\n    \"\"\"\n    source = self\n\n    async def subscribe_async(subscriber: Subscriber[A]) -&gt; None:\n        async def on_next(value: A) -&gt; Acknowledgement:\n            if predicate(value):\n                return await subscriber.on_next(value)\n            else:\n                # call on_completed when predicate violated\n                await subscriber.on_completed()\n                return Acknowledgement.stop\n\n        take_subscriber = create_subscriber(\n            on_next=on_next, on_error=subscriber.on_error, on_completed=subscriber.on_completed\n        )\n\n        await source.subscribe(take_subscriber)\n\n    return create_observable(subscribe_async)\n</code></pre>"},{"location":"2_observable_methods/#grugstream.core.Observable.take_while_inclusive","title":"<code>take_while_inclusive(predicate)</code>","text":"<p>Take values until predicate is false.</p> <p>Stops after emitting the last value where <code>predicate</code> is true.</p> <p>Parameters:</p> Name Type Description Default <code>predicate</code> <code>Callable</code> <p>Function to test each value.</p> required <p>Returns:</p> Type Description <code>Observable</code> <p>Observable emitting values until predicate is false.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; obs = Observable.from_iterable([1, 2, 3, 4, 5])\n&gt;&gt;&gt; taken = obs.take_while_inclusive(lambda x: x &lt; 4)\n&gt;&gt;&gt; await taken.to_list()\n[1, 2, 3, 4]\n</code></pre> Source code in <code>grugstream/core.py</code> <pre><code>def take_while_inclusive(self: Observable[A], predicate: Callable[[A], bool]) -&gt; 'Observable[A]':\n    \"\"\"Take values until predicate is false.\n\n    Stops **after** emitting the last value where `predicate` is true.\n\n    Parameters\n    ----------\n    predicate : Callable\n        Function to test each value.\n\n    Returns\n    -------\n    Observable\n        Observable emitting values until predicate is false.\n\n    Examples\n    --------\n    &gt;&gt;&gt; obs = Observable.from_iterable([1, 2, 3, 4, 5])\n    &gt;&gt;&gt; taken = obs.take_while_inclusive(lambda x: x &lt; 4)\n    &gt;&gt;&gt; await taken.to_list()\n    [1, 2, 3, 4]\n    \"\"\"\n    source = self\n\n    async def subscribe_async(subscriber: Subscriber[A]) -&gt; None:\n        async def on_next(value: A) -&gt; Acknowledgement:\n            if predicate(value):\n                return await subscriber.on_next(value)\n            else:\n                # include the violating element in the stream\n                await subscriber.on_next(value)\n                # call on_completed when predicate violated\n                await subscriber.on_completed()\n                return Acknowledgement.stop\n\n        take_subscriber = create_subscriber(\n            on_next=on_next, on_error=subscriber.on_error, on_completed=subscriber.on_completed\n        )\n\n        await source.subscribe(take_subscriber)\n\n    return create_observable(subscribe_async)\n</code></pre>"},{"location":"2_observable_methods/#grugstream.core.Observable.throttle","title":"<code>throttle(seconds, max_buffer_size=1)</code>","text":"<p>Throttle emissions to at most one per <code>seconds</code> interval.</p> <p>Parameters:</p> Name Type Description Default <code>seconds</code> <code>float</code> <p>Interval duration between emissions</p> required <code>max_buffer_size</code> <code>int</code> <p>Max number of values to buffer</p> <code>1</code> <p>Returns:</p> Type Description <code>Observable</code> <p>Throttled Observatory allowing at most one emission per interval</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; obs = Observable.interval(0.1)\n&gt;&gt;&gt; throttled = obs.throttle(1.0)\n&gt;&gt;&gt; await throttled.take(3).to_list()\n[0, 1, 2] # emitted at 1 second intervals\n</code></pre> Source code in <code>grugstream/core.py</code> <pre><code>def throttle(self, seconds: float, max_buffer_size: int = 1) -&gt; 'Observable[A_co]':\n    \"\"\"Throttle emissions to at most one per `seconds` interval.\n\n    Parameters\n    ----------\n    seconds : float\n        Interval duration between emissions\n    max_buffer_size : int, default 1\n        Max number of values to buffer\n\n    Returns\n    -------\n    Observable\n        Throttled Observatory allowing at most one emission per interval\n\n    Examples\n    --------\n    &gt;&gt;&gt; obs = Observable.interval(0.1)\n    &gt;&gt;&gt; throttled = obs.throttle(1.0)\n    &gt;&gt;&gt; await throttled.take(3).to_list()\n    [0, 1, 2] # emitted at 1 second intervals\n    \"\"\"\n    source = self\n    send_stream, receive_stream = create_memory_object_stream(max_buffer_size=max_buffer_size)  # type: ignore\n\n    class ThrottledObservable(Observable[A]):\n        async def subscribe(self, subscriber: Subscriber[A]) -&gt; None:\n            async def wait_and_forward() -&gt; None:\n                async with create_task_group() as tg:\n                    # Producer task\n                    tg.start_soon(source.subscribe, send_to_stream_subscriber)\n\n                    # Consumer task\n                    tg.start_soon(send_periodically, tg)\n\n            async def send_periodically(tg: TaskGroup) -&gt; None:\n                while True:\n                    await anyio.sleep(seconds)\n                    try:\n                        value = receive_stream.receive_nowait()\n                        response = await subscriber.on_next(value)  # type: ignore\n                        if response == Acknowledgement.stop:\n                            await subscriber.on_completed()\n                            tg.cancel_scope.cancel()\n                            break\n                    except anyio.WouldBlock:\n                        # No new elements, keep waiting\n                        continue\n                    except EndOfStream:\n                        await subscriber.on_completed()\n                        break\n\n            async def on_next(value: A) -&gt; Acknowledgement:\n                await send_stream.send(value)\n                return Acknowledgement.ok\n\n            async def on_completed() -&gt; None:\n                await send_stream.aclose()\n\n            async def on_error(e: Exception) -&gt; None:\n                send_stream.close()\n                await subscriber.on_error(e)\n\n            send_to_stream_subscriber = create_subscriber(\n                on_next=on_next, on_completed=on_completed, on_error=on_error\n            )\n\n            await wait_and_forward()\n\n    return ThrottledObservable()\n</code></pre>"},{"location":"2_observable_methods/#grugstream.core.Observable.to_async_iterable","title":"<code>to_async_iterable()</code>  <code>async</code>","text":"<p>Collect values into an async iterable.</p> <p>Returns:</p> Type Description <code>AsyncIterable[A_co]</code> <p>Async iterable containing all emitted values.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; obs = Observable.from_iterable([1, 2, 3])\n&gt;&gt;&gt; async for value in obs.to_async_iterable():\n&gt;&gt;&gt;     print(value)\n1\n2\n3\n</code></pre> Source code in <code>grugstream/core.py</code> <pre><code>async def to_async_iterable(self) -&gt; AsyncIterable[A_co]:\n    \"\"\"Collect values into an async iterable.\n\n    Returns\n    -------\n    AsyncIterable[A_co]\n        Async iterable containing all emitted values.\n\n    Examples\n    --------\n    &gt;&gt;&gt; obs = Observable.from_iterable([1, 2, 3])\n    &gt;&gt;&gt; async for value in obs.to_async_iterable():\n    &gt;&gt;&gt;     print(value)\n    1\n    2\n    3\n    \"\"\"\n    items = []\n    event = anyio.Event()\n    processing_limit = anyio.CapacityLimiter(1)\n\n    class BufferingSubscriber(Subscriber[A]):\n        async def on_next(self, value: A) -&gt; Acknowledgement:\n            await processing_limit.acquire_on_behalf_of(value)\n            items.append(value)\n            return Acknowledgement.ok\n\n        async def on_error(self, error: Exception) -&gt; None:\n            event.set()\n            raise error\n\n        async def on_completed(self) -&gt; None:\n            event.set()\n\n    buffering_subscriber = BufferingSubscriber()\n    async with anyio.create_task_group() as task_group:\n\n        async def run_subscription():\n            try:\n                await self.subscribe(buffering_subscriber)\n            finally:\n                event.set()\n\n        task_group.start_soon(run_subscription)\n\n        while not event.is_set() or items:\n            await anyio.sleep(0)\n\n            while items:\n                item = items.pop(0)\n                if isinstance(item, Exception):\n                    raise item\n                else:\n                    yield item\n                processing_limit.release_on_behalf_of(item)\n</code></pre>"},{"location":"2_observable_methods/#grugstream.core.Observable.to_file_appending","title":"<code>to_file_appending(file_path, serialize=str, write_newline=True)</code>  <code>async</code>","text":"<p>Write all emitted values to a file, by appending. Note that this appends to a file, rather than overwriting it.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>Path</code> <p>Path to write output file to.</p> required <code>serialize</code> <code>Callable</code> <p>Function to serialize items to strings.</p> <code>str</code> <code>write_newline</code> <code>bool</code> <p>Whether to write newline after each value.</p> <code>True</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; obs = Observable.from_iterable([1, 2, 3])\n&gt;&gt;&gt; await obs.to_file('data.txt')\n</code></pre> Source code in <code>grugstream/core.py</code> <pre><code>async def to_file_appending(\n    self: Observable[A],\n    file_path: Path,\n    serialize: Callable[[A], str] = str,\n    write_newline: bool = True,\n) -&gt; None:\n    \"\"\"Write all emitted values to a file, by appending.\n    Note that this appends to a file, rather than overwriting it.\n\n    Parameters\n    ----------\n    file_path : Path\n        Path to write output file to.\n    serialize : Callable, default str\n        Function to serialize items to strings.\n    write_newline : bool, default True\n        Whether to write newline after each value.\n    Examples\n    --------\n    &gt;&gt;&gt; obs = Observable.from_iterable([1, 2, 3])\n    &gt;&gt;&gt; await obs.to_file('data.txt')\n    \"\"\"\n\n    # lock to prevent multiple awaitables from writing at the same time\n    can_write = anyio.Semaphore(1)\n\n    class AnonymousSubscriber(Subscriber[Any]):\n        def __init__(self) -&gt; None:\n            self.file_handlers: dict[Path, AsyncFile[str]] = {}\n\n        async def on_next(self, value: A) -&gt; Acknowledgement:\n            # Only open file ONCE when first value is received\n            if file_path not in self.file_handlers:\n                file_path.touch(exist_ok=True)\n                file = await anyio.open_file(file_path, mode=\"a\")\n                self.file_handlers[file_path] = file\n            else:\n                file = self.file_handlers[file_path]\n            async with can_write:\n                await file.write(serialize(value) + ('\\n' if write_newline else ''))\n            return Acknowledgement.ok\n\n        async def on_error(self, error: Exception) -&gt; None:\n            file = self.file_handlers.get(file_path)\n            if file is not None:\n                await file.aclose()\n            raise error\n\n        async def on_completed(self) -&gt; None:\n            file = self.file_handlers.get(file_path)\n            if file is not None:\n                await file.aclose()\n            return None\n\n    new_subscriber = AnonymousSubscriber()\n\n    await self.subscribe(new_subscriber)\n</code></pre>"},{"location":"2_observable_methods/#grugstream.core.Observable.to_file_overwriting","title":"<code>to_file_overwriting(file_path, serialize=str, write_newline=True, write_every_n=100)</code>  <code>async</code>","text":"<p>Write all emitted values to a file, by overwriting the current file. Note that this stores values to a buffer, so this can lead to an OOM in large files. We recommend to use to_file_appending instead if memory is a concern</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>Path</code> <p>Path to write output file to.</p> required <code>serialize</code> <code>Callable</code> <p>Function to serialize items to strings.</p> <code>str</code> <code>write_newline</code> <code>bool</code> <p>Whether to write newline after each value.</p> <code>True</code> <code>write_every_n</code> <code>int</code> <p>Only writes to the file every n values. A higher value prevents your stream from slowing down due to slow write times.</p> <code>200</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; obs = Observable.from_iterable([1, 2, 3])\n&gt;&gt;&gt; await obs.to_file('data.txt')\n</code></pre> Source code in <code>grugstream/core.py</code> <pre><code>async def to_file_overwriting(\n    self: Observable[A],\n    file_path: Path,\n    serialize: Callable[[A], str] = str,\n    write_newline: bool = True,\n    write_every_n: int = 100,\n) -&gt; None:\n    \"\"\"Write all emitted values to a file, by overwriting the current file.\n    Note that this stores values to a buffer, so this can lead to an OOM in large files.\n    We recommend to use to_file_appending instead if memory is a concern\n\n    Parameters\n    ----------\n    file_path : Path\n        Path to write output file to.\n    serialize : Callable, default str\n        Function to serialize items to strings.\n    write_newline : bool, default True\n        Whether to write newline after each value.\n    write_every_n : int, default 200\n        Only writes to the file every n values. A higher value prevents your stream from slowing\n        down due to slow write times.\n\n    Examples\n    --------\n    &gt;&gt;&gt; obs = Observable.from_iterable([1, 2, 3])\n    &gt;&gt;&gt; await obs.to_file('data.txt')\n    \"\"\"\n\n    # lock to prevent multiple awaitables from writing at the same time\n    can_write = anyio.Semaphore(1)\n    buffer: list[str] = []\n\n    class AnonymousSubscriber(Subscriber[Any]):\n        def __init__(self) -&gt; None:\n            self.file_handlers: dict[Path, AsyncFile[str]] = {}\n\n        async def on_next(self, value: A) -&gt; Acknowledgement:\n            # Only open file ONCE when first value is received\n            if file_path not in self.file_handlers:\n                # First time\n                file_path.parent.touch(exist_ok=True)\n                file = await anyio.open_file(file_path, mode=\"w\")\n                self.file_handlers[file_path] = file\n            else:\n                file = self.file_handlers[file_path]\n            async with can_write:\n                buffer.append(serialize(value) + ('\\n' if write_newline else ''))\n                if len(buffer) == write_every_n:\n                    await file.writelines(buffer)\n            return Acknowledgement.ok\n\n        async def on_error(self, error: Exception) -&gt; None:\n            file = self.file_handlers.get(file_path)\n            if file is not None:\n                async with can_write:\n                    # Write the buffer\n                    await file.writelines(buffer)\n                    await file.aclose()\n            raise error\n\n        async def on_completed(self) -&gt; None:\n            file = self.file_handlers.get(file_path)\n            if file is not None:\n                async with can_write:\n                    # Write the buffer\n                    await file.writelines(buffer)\n                    await file.aclose()\n            return None\n\n    new_subscriber = AnonymousSubscriber()\n\n    await self.subscribe(new_subscriber)\n</code></pre>"},{"location":"2_observable_methods/#grugstream.core.Observable.to_list","title":"<code>to_list()</code>  <code>async</code>","text":"<p>Collect all values from the Observable into a list.</p> <p>Returns:</p> Type Description <code>list</code> <p>List containing all values emitted by the Observable.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; obs = Observable.from_interval(0.1).take(3)\n&gt;&gt;&gt; await obs.to_list()\n[1, 2, 3]\n</code></pre> Source code in <code>grugstream/core.py</code> <pre><code>async def to_list(self: Observable[A]) -&gt; list[A]:\n    \"\"\"Collect all values from the Observable into a list.\n\n    Returns\n    -------\n    list\n        List containing all values emitted by the Observable.\n\n    Examples\n    --------\n    &gt;&gt;&gt; obs = Observable.from_interval(0.1).take(3)\n    &gt;&gt;&gt; await obs.to_list()\n    [1, 2, 3]\n    \"\"\"\n    result = []\n\n    async def on_next(value: A) -&gt; Acknowledgement:\n        result.append(value)\n        return Acknowledgement.ok\n\n    list_subscriber: Subscriber[A] = create_subscriber(\n        on_next=on_next,\n        on_error=None,\n        on_completed=None,\n    )\n    await self.subscribe(list_subscriber)\n\n    return result\n</code></pre>"},{"location":"2_observable_methods/#grugstream.core.Observable.to_set","title":"<code>to_set()</code>  <code>async</code>","text":"<p>Collect values into a set, removing duplicates.</p> <p>Returns:</p> Type Description <code>set</code> <p>Set containing unique values emitted.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; obs = Observable.from_iterable([1, 2, 1])\n&gt;&gt;&gt; await obs.to_set()\n{1, 2}\n</code></pre> Source code in <code>grugstream/core.py</code> <pre><code>async def to_set(self: \"Observable[CanHash]\") -&gt; set[CanHash]:\n    \"\"\"Collect values into a set, removing duplicates.\n\n    Returns\n    -------\n    set\n        Set containing unique values emitted.\n\n    Examples\n    --------\n    &gt;&gt;&gt; obs = Observable.from_iterable([1, 2, 1])\n    &gt;&gt;&gt; await obs.to_set()\n    {1, 2}\n    \"\"\"\n    result = set()\n\n    async def on_next(value: CanHash) -&gt; Acknowledgement:\n        result.add(value)\n        return Acknowledgement.ok\n\n    set_subscriber = create_subscriber(on_next=on_next, on_completed=None, on_error=None)\n\n    await self.subscribe(set_subscriber)\n\n    return result\n</code></pre>"},{"location":"2_observable_methods/#grugstream.core.Observable.to_slist","title":"<code>to_slist()</code>  <code>async</code>","text":"<p>Collect values into an Slist.</p> <p>Returns:</p> Type Description <code>Slist</code> <p>Slist containing all values emitted.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; obs = Observable.from_iterable([1, 2, 3])\n&gt;&gt;&gt; await obs.to_slist()\nSlist([1, 2, 3])\n</code></pre> Source code in <code>grugstream/core.py</code> <pre><code>async def to_slist(self) -&gt; 'Slist[A_co]':\n    \"\"\"Collect values into an Slist.\n\n    Returns\n    -------\n    Slist\n        Slist containing all values emitted.\n\n    Examples\n    --------\n    &gt;&gt;&gt; obs = Observable.from_iterable([1, 2, 3])\n    &gt;&gt;&gt; await obs.to_slist()\n    Slist([1, 2, 3])\n    \"\"\"\n    return Slist(await self.to_list())\n</code></pre>"},{"location":"2_observable_methods/#grugstream.core.Observable.tqdm","title":"<code>tqdm(tqdm_bar=None)</code>","text":"<p>Wrap the Observable with a tqdm progress bar.</p> <p>Parameters:</p> Name Type Description Default <code>tqdm_bar</code> <code>Optional[tqdm]</code> <p>tqdm progress bar to use, or None to use default</p> <code>None</code> <p>Returns:</p> Type Description <code>Observable</code> <p>Wrapped Observatory with tqdm progress bar</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tqdm import tqdm\n&gt;&gt;&gt; pbar = tqdm(desc=\"Progress\")\n&gt;&gt;&gt; obs = Observable.from_interval(1)\n&gt;&gt;&gt; obs.tqdm(pbar).take(10).run_to_completion()\n# pbar will show 1 it/s progress\n</code></pre> Source code in <code>grugstream/core.py</code> <pre><code>def tqdm(self, tqdm_bar: Optional[tqdm] = None) -&gt; 'Observable[A_co]':  # type: ignore\n    \"\"\"Wrap the Observable with a tqdm progress bar.\n\n    Parameters\n    ----------\n    tqdm_bar : Optional[tqdm], default None\n        tqdm progress bar to use, or None to use default\n\n    Returns\n    -------\n    Observable\n        Wrapped Observatory with tqdm progress bar\n\n    Examples\n    --------\n    &gt;&gt;&gt; from tqdm import tqdm\n    &gt;&gt;&gt; pbar = tqdm(desc=\"Progress\")\n    &gt;&gt;&gt; obs = Observable.from_interval(1)\n    &gt;&gt;&gt; obs.tqdm(pbar).take(10).run_to_completion()\n    # pbar will show 1 it/s progress\n    \"\"\"\n    source = self\n\n    try:\n        from tqdm import tqdm\n    except ImportError:\n        raise ImportError(\"You need to install tqdm to use this function.\")\n\n    class TQDMObservable(Observable[A]):\n        async def subscribe(self, subscriber) -&gt; None:\n            pbar = tqdm(dynamic_ncols=True) if tqdm_bar is None else tqdm_bar  # type: ignore\n\n            async def on_next(value: A) -&gt; Acknowledgement:\n                pbar.update(1)\n                return await subscriber.on_next(value)\n\n            async def on_completed() -&gt; None:\n                pbar.close()\n                await subscriber.on_completed()\n\n            async def on_error(e: Exception) -&gt; None:\n                pbar.close()\n                await subscriber.on_error(e)\n\n            wrapped_subscriber = create_subscriber(on_next=on_next, on_completed=on_completed, on_error=on_error)\n\n            await source.subscribe(wrapped_subscriber)\n\n    return TQDMObservable()\n</code></pre>"},{"location":"3_cookbook/","title":"Cookbook","text":""},{"location":"3_cookbook/#memory-efficient-file-processing","title":"Memory efficient file processing","text":"<p>If you have a large file, you can process it line by line without loading the whole file into memory. <pre><code>import asyncio\nimport random\nimport string\nfrom pathlib import Path\n\nfrom tqdm import tqdm\n\nfrom grugstream import Observable\n\n\nasync def fake_google_search(query: str) -&gt; list[dict[str, str]]:\n    \"\"\"\n    Fake Google search that returns a list of results.\n    \"\"\"\n    await asyncio.sleep(1)\n    return [{\"result\": f\"Result {i} for {query}\", \"query\": query} for i in range(10)]\n\n\ndef generate_random_string():\n    # Get all the ASCII letters in lowercase and uppercase\n    letters = string.ascii_letters\n    # Randomly get a sized 10 string from the letters\n    random_string = ''.join(random.choice(letters) for _ in range(10))\n    return random_string\n\n\ndef create_big_file(file_name: str):\n    with open(file_name, \"w\") as f:\n        for i in range(1000000):\n            to_write = generate_random_string()\n            f.write(f\"{to_write}\\n\")\n\n\nasync def main():\n    file_name = \"big_file.txt\"\n    # Dump a big file, just for example purposes\n    create_big_file(file_name)\n\n    observable = (\n        # Read the file line by line\n        Observable.from_file(Path(file_name))\n        # Search google in parallel\n        .map_async_par(fake_google_search, max_par=10)\n        # Make a tqdm bar\n        .tqdm(tqdm_bar=tqdm(desc=\"Searching Google\", unit_scale=1))\n        # Since we get a list of results, we want to flatten it\n        .flatten_list()\n        # We want to stop after 1000 results\n        .take(1000)\n    )\n    # Output the results to a file line by line\n    await observable.to_file_appending(Path(\"results.txt\"))\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre></p>"},{"location":"3_cookbook/#web-crawler-adding-items-back-to-the-start","title":"Web crawler - Adding items back to the start","text":"<p>Some streams are more complicated that others. Usually a stream is like <pre><code>start -&gt; apply some functions -&gt; end\n</code></pre></p> <p>But sometimes you need to do more complicated things where you want to add the processed items back to the start of the stream. <pre><code>start -&gt; apply some functions -&gt; add more things to the start -&gt; repeat\n</code></pre></p> <p>A web crawler is a good example of this. You can easily write a concurrent web crawler with grugstream.  Here's an example of crawling from one website recursively for 1000 links:</p> <pre><code>from pathlib import Path\nfrom typing import List, Optional\nimport asyncio\n\nfrom aiohttp import ClientSession\nfrom anyio import create_memory_object_stream, create_task_group\nfrom anyio.streams.memory import MemoryObjectSendStream, MemoryObjectReceiveStream\nfrom bs4 import BeautifulSoup\n\nfrom grugstream import Observable\n\nheaders = {\"User-Agent\": \"AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124\"}\n\n\nasync def fetch_page_content(url: str) -&gt; Optional[str]:\n    \"\"\"\n    Fetches the content of the specified URL using aiohttp.\n    \"\"\"\n    async with ClientSession() as session:\n        async with session.get(url, headers=headers) as response:\n            try:\n                text = await response.text()\n                return text\n            # Sometimes we get a UnicodeDecodeError, let's just ignore it\n            except UnicodeDecodeError:\n                return None\n\n\ndef extract_hyperlinks_from_content(content: str) -&gt; List[str]:\n    \"\"\"\n    Extracts all hyperlinks from the given content using BeautifulSoup.\n    \"\"\"\n    soup = BeautifulSoup(content, 'html.parser')\n    links = [a['href'] for a in soup.find_all('a', href=True)]\n    return links\n\n\nasync def get_all_hyperlinks(url: str) -&gt; List[str]:\n    \"\"\"\n    Fetches content of the specified URL and extracts all hyperlinks.\n    \"\"\"\n    content = await fetch_page_content(url)\n    return extract_hyperlinks_from_content(content) if content else []\n\n\ndef is_valid_url(url: str) -&gt; bool:\n    return url.startswith(\"http\")\n\n\nasync def main():\n    url_to_crawl = \"https://webscraper.io/test-sites/e-commerce/allinone\"\n\n    async def run_crawler(\n        receive_stream: MemoryObjectReceiveStream[str], send_stream: MemoryObjectSendStream[str]\n    ) -&gt; None:\n        already_seen = set()\n        pipeline: Observable[str] = (\n            Observable\n            # Create an Observable from the receive_stream\n            .from_receive_stream(receive_stream)\n            .print(prefix=\"Starting to crawl: \")\n            .map_async_par(get_all_hyperlinks)\n            # flatten the list of lists into a single list\n            .flatten_list()\n            # only keep valid urls\n            .filter(is_valid_url)\n            # only carry on links we haven't seen before\n            .filter(lambda link: link not in already_seen)\n            # track it so we don't crawl it again\n            .for_each(lambda link: already_seen.add(link))\n            .print(prefix=\"Sending new link to crawl \")\n            # send it back to the send_stream for processing\n            .for_each_to_stream(send_stream)\n            # We only want to crawl 1000 links\n            .take(1000)\n            # output it to a file to save\n            .for_each_to_file_appending(file_path=Path(\"results.txt\"))\n        )\n        await pipeline.run_to_completion()\n\n    send_stream, receive_stream = create_memory_object_stream[str](max_buffer_size=100)\n    async with create_task_group() as tg:\n        tg.start_soon(run_crawler, receive_stream, send_stream)\n        # don't close the send_stream, we want to keep sending items to it\n        await send_stream.send(url_to_crawl)\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"}]}